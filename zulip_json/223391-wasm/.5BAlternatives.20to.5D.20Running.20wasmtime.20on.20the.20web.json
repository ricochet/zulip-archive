[
    {
        "content": "<p>Hi there!</p>\n<p>This is an odd question and I wouldn't be surprised if there are no easy answers. That being said - I work on <a href=\"https://github.com/AmbientRun/Ambient\">Ambient</a>, which is a platform for games and other 3D experiences, where all serverside user logic is defined in WASM with wit-bindgen powered bindings and run by wasmtime.</p>\n<p>We're looking at getting our client to run on the web through compiling to WASM and don't anticipate too many issues there. However, we <em>also</em> want to support clientside WASM logic in the short to medium future, so that people can define complex clientside logic / show UI / what have you.</p>\n<p>This puts us in an unfortunate situation: we'll need a way to run this WASM logic on the web, and preferably without <em>too</em> much maintenance burden. Running wasmtime on the web is, as far as I can tell, not really a viable option: <a href=\"https://docs.wasmtime.dev/stability-platform-support.html#interpreter-support\">there's no interpreter support</a>. (It's also unclear if running a WASM interpreter inside WASM is really that good of an idea, even if the work done will be fairly limited.)</p>\n<p>I'm thinking that we could potentially run the modules through Web Workers, but the next open question there is how we'd handle wit-bindgen. We're using an older pre-CM version and will update soon. Even if we do, though, is there a solution to using the CM/WIT on the web today?</p>\n<p>Any suggestions would be appreciated. Happy to clarify anything as well <span aria-label=\"rocket\" class=\"emoji emoji-1f680\" role=\"img\" title=\"rocket\">:rocket:</span></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/AmbientRun/Ambient\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/6a996f01801c32b579a63ae0330c449f9154c1f1\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f306133626332343534306161636232363665653732663937653465633631646438366131376335393035383665363535666464626565326635383466366333642f416d6269656e7452756e2f416d6269656e74)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/AmbientRun/Ambient\" title=\"GitHub - AmbientRun/Ambient: The multiplayer game engine\">GitHub - AmbientRun/Ambient: The multiplayer game engine</a></div><div class=\"message_embed_description\">The multiplayer game engine. Contribute to AmbientRun/Ambient development by creating an account on GitHub.</div></div></div>",
        "id": 338309287,
        "sender_full_name": "Philpax",
        "timestamp": 1677499639
    },
    {
        "content": "<p><a href=\"https://github.com/bytecodealliance/jco\">https://github.com/bytecodealliance/jco</a> allows turning wasm components into wasm code modules and javascript for bindings. I don't know if it works directly in the browser though, which is why I opened <a href=\"https://github.com/bytecodealliance/jco/issues/42\">https://github.com/bytecodealliance/jco/issues/42</a>.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/jco\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/3b0fcd763248cdb93f069d14641af78a24b8fdef\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f626663303234633862653362323430336433356636306537383061633735643866366636646437333765333834303765393961383264303363386266323935662f62797465636f6465616c6c69616e63652f6a636f)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/jco\" title=\"GitHub - bytecodealliance/jco: JavaScript tooling for working with WebAssembly Components\">GitHub - bytecodealliance/jco: JavaScript tooling for working with WebAssembly Components</a></div><div class=\"message_embed_description\">JavaScript tooling for working with WebAssembly Components - GitHub - bytecodealliance/jco: JavaScript tooling for working with WebAssembly Components</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/jco/issues/42\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/72dff6f83add3f936c278e2192f6add3e746f41c\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663233326436633332636665313564623865613766393637363632396165383235616536393531653462653962363738366637326661336434373731366133362f62797465636f6465616c6c69616e63652f6a636f2f6973737565732f3432)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/jco/issues/42\" title=\"Browser usage? · Issue #42 · bytecodealliance/jco\">Browser usage? · Issue #42 · bytecodealliance/jco</a></div><div class=\"message_embed_description\">I did like to use jco for handling wasi preview2 in browser_wasi_shim. Is it possible to use jco directly in the browser to take a wasm component, run the transpilation step and directly run it as ...</div></div></div>",
        "id": 338317205,
        "sender_full_name": "bjorn3",
        "timestamp": 1677501972
    },
    {
        "content": "<p>I think the intention is that wasm components will be natively supported by browsers in the future.</p>",
        "id": 338317336,
        "sender_full_name": "bjorn3",
        "timestamp": 1677502010
    },
    {
        "content": "<p>I think it would be possible to implement most of at least the non-async version of wasmtime's api to work in the browser using the browser's native wasm support to allow code to run with minimal changes, but I have no clue how much work that would be.</p>",
        "id": 338317867,
        "sender_full_name": "bjorn3",
        "timestamp": 1677502136
    },
    {
        "content": "<p>as bjorn3 says, using jco you can run components in the browser as well as in JS runtimes such as Node.js and Deno. I would strongly recommend trying to structure components such that they don't rely on wasmtime-specific APIs, and instead use ones that are easy and efficient to implement in browsers and other environments as well. That might admittedly not be straight-forward, but we'll be happy to support you here on Zulip however we can</p>",
        "id": 338318832,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1677502390
    },
    {
        "content": "<p>(also, Ambient is really cool and I'm very excited you're betting on WebAssembly and Wasmtime in this way! <span aria-label=\"partying face\" class=\"emoji emoji-1f973\" role=\"img\" title=\"partying face\">:partying_face:</span> <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>)</p>",
        "id": 338318991,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1677502433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"264278\">bjorn3</span> <a href=\"#narrow/stream/223391-wasm/topic/.5BAlternatives.20to.5D.20Running.20wasmtime.20on.20the.20web/near/338317205\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/bytecodealliance/jco\">https://github.com/bytecodealliance/jco</a> allows turning wasm components into wasm code modules and javascript for bindings. I don't know if it works directly in the browser though, which is why I opened <a href=\"https://github.com/bytecodealliance/jco/issues/42\">https://github.com/bytecodealliance/jco/issues/42</a>.</p>\n</blockquote>\n<p>Hm, that's a really interesting idea! We could potentially unpack the components (using <code>wit-component</code> etc) and drive them. The only problem would be actually calling the functions, but we could potentially define our own <code>wit-bindgen</code> host generator to swap out <code>wasmtime</code> calls for talking to the other modules?</p>",
        "id": 338325714,
        "sender_full_name": "Philpax",
        "timestamp": 1677504225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234973\">Till Schneidereit</span> <a href=\"#narrow/stream/223391-wasm/topic/.5BAlternatives.20to.5D.20Running.20wasmtime.20on.20the.20web/near/338318832\">said</a>:</p>\n<blockquote>\n<p>as bjorn3 says, using jco you can run components in the browser as well as in JS runtimes such as Node.js and Deno. I would strongly recommend trying to structure components such that they don't rely on wasmtime-specific APIs, and instead use ones that are easy and efficient to implement in browsers and other environments as well. That might admittedly not be straight-forward, but we'll be happy to support you here on Zulip however we can</p>\n</blockquote>\n<p>Yeah, we don't actually explicitly use any wasmtime APIs - we just use WASI (but only really time / stdio) and wit-bindgen-generated bindings. I suspect that our guest code would just work if run on another VM if the bindings were hooked up correctly.</p>",
        "id": 338326071,
        "sender_full_name": "Philpax",
        "timestamp": 1677504300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234973\">Till Schneidereit</span> <a href=\"#narrow/stream/223391-wasm/topic/.5BAlternatives.20to.5D.20Running.20wasmtime.20on.20the.20web/near/338318991\">said</a>:</p>\n<blockquote>\n<p>(also, Ambient is really cool and I'm very excited you're betting on WebAssembly and Wasmtime in this way! <span aria-label=\"partying face\" class=\"emoji emoji-1f973\" role=\"img\" title=\"partying face\">:partying_face:</span> <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>)</p>\n</blockquote>\n<p>Thank you! Yeah, we're really excited about it too - it's something that I've wanted to see for <em>years</em> now, and I'm glad it's starting to become possible today :)</p>",
        "id": 338326191,
        "sender_full_name": "Philpax",
        "timestamp": 1677504324
    },
    {
        "content": "<p>if you're only using WASI, then jco in combination with the preview2 work should \"just work\", at least once you've moved to components, and once all the WASI features you need are implemented</p>",
        "id": 338347440,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1677509225
    },
    {
        "content": "<p>I'm not sure if <code>jco</code> would work for us? The WASM/component to run would be streamed to the client when they join the server; they wouldn't have access to a JS toolchain. I suspect what we'd need to do is use the component library tooling to unpack the component, spawn the WASM bytecode as its own module, and then figure out a way to bridge our client (responsible for spawning the components) to the spawned components. Some kind of synchronous messaging, perhaps?</p>",
        "id": 338350682,
        "sender_full_name": "Philpax",
        "timestamp": 1677509942
    },
    {
        "content": "<p>If jco runs in the browser and produces javascript and wasm that can directly be evaluated you could run it on the client right before running the wasm component. I don't know if this is the case, hence why I opened <a href=\"https://github.com/bytecodealliance/jco/issues/42\">https://github.com/bytecodealliance/jco/issues/42</a> to request clarification.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/jco/issues/42\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/72dff6f83add3f936c278e2192f6add3e746f41c\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663233326436633332636665313564623865613766393637363632396165383235616536393531653462653962363738366637326661336434373731366133362f62797465636f6465616c6c69616e63652f6a636f2f6973737565732f3432)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/jco/issues/42\" title=\"Browser usage? · Issue #42 · bytecodealliance/jco\">Browser usage? · Issue #42 · bytecodealliance/jco</a></div><div class=\"message_embed_description\">I did like to use jco for handling wasi preview2 in browser_wasi_shim. Is it possible to use jco directly in the browser to take a wasm component, run the transpilation step and directly run it as ...</div></div></div>",
        "id": 338404125,
        "sender_full_name": "bjorn3",
        "timestamp": 1677519049
    },
    {
        "content": "<p>Gotcha, thanks! I'll keep an eye on this - for now, I have my hands full getting us up to date with the CM <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 338576406,
        "sender_full_name": "Philpax",
        "timestamp": 1677588107
    },
    {
        "content": "<p>Hi all! I return from the future <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<p>We've been chugging away for the last few months, and are getting pretty close to getting Ambient running on the web. (Un)fortunately, this also means we need to figure out how to solve this <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>Using the proposed solution above, I believe the workflow would be:</p>\n<ul>\n<li>Ambient (runtime, compiled as WASM with wasm-bindgen) downloads the clientside logic WASM/WIT component</li>\n<li>This component is then sent to the \"host\" JavaScript that's managing Ambient</li>\n<li>The JavaScript then runs JCO on the component to create a JavaScript object that can be called</li>\n<li>The component and runtime are then dynamically linked by the JavaScript, so that when <ul>\n<li>the runtime requests that the component run, its entrypoint is called </li>\n<li>the component requests to call something from the runtime<br>\n    - the component will call out to the JavaScript, which will then talk to the runtime somehow (can't use WIT, as the runtime's compiled with wasm-bindgen)<br>\n    - the JavaScript then gets the result from the runtime, and returns to the component with the result</li>\n</ul>\n</li>\n</ul>\n<p>The open questions I have about this are:</p>\n<ul>\n<li>Can JCO be made to run on the web? It looks like people have started working on this last week (lucky timing!), so I'm hoping that will turn out to be a yes.</li>\n<li>Is there overhead to using JCO for this? It seems like a lot of marshalling back/to JavaScript.</li>\n<li>It seems like we'd have to set up our own communication protocol/layer from guest+JS -&gt; runtime, because we can't reuse WIT.</li>\n</ul>\n<p>This seems doable, but not ideal.</p>\n<hr>\n<p>I was wondering how accessible the machinery for WIT is. I think the ideal solution would look like is something like <code>wasmtime::component::bindgen</code>, but instead of using <code>wasmtime</code> APIs on the web, we use the web APIs for manipulating and calling WebAssembly.</p>\n<p>How feasible would it be for us to write our own <code>bindgen</code>-like macro that generates calls to <code>web-sys</code> instead? Would this be a feasible plan of attack, or is the JCO plan still conceptually simpler? Ideally, we can replicate the <code>wasmtime</code> logic and swap out the <code>wasmtime</code> calls for <code>web-sys</code> calls. I imagine it's not quite so simple, though...</p>\n<p>We'd base it off <code>wasmtime</code>'s <code>bindgen</code> to maintain compatibility as much as possible - it'd be a real shame if we had to write two sets of bindings for the same thing!</p>\n<p>I appreciate any input on this; I'm really looking forward to seeing a WASM-\"on\"-WASM deployment!</p>",
        "id": 370532311,
        "sender_full_name": "Philpax",
        "timestamp": 1687976433
    },
    {
        "content": "<p>On the jco side, there is a tracking issue in <a href=\"https://github.com/bytecodealliance/jco/issues/42\">https://github.com/bytecodealliance/jco/issues/42</a> for jco in browsers, and we have already started chipping away on this. I'm currently working on WASI virtualization which should also unlock the remaining part of this.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/jco/issues/42\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/77724b86168aad98d0bd914d3c47a3648d2bc680\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363766623635313666386362653832306131343564383533623031306463346335623866323964616338373137383435316331323737663735666438313030392f62797465636f6465616c6c69616e63652f6a636f2f6973737565732f3432)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/jco/issues/42\" title=\"Browser support · Issue #42 · bytecodealliance/jco\">Browser support · Issue #42 · bytecodealliance/jco</a></div><div class=\"message_embed_description\">I did like to use jco for handling wasi preview2 in browser_wasi_shim. Is it possible to use jco directly in the browser to take a wasm component, run the transpilation step and directly run it as ...</div></div></div>",
        "id": 370532940,
        "sender_full_name": "Guy Bedford",
        "timestamp": 1687976546
    },
    {
        "content": "<p>Thanks for letting me know!</p>\n<p>My primary concern with the jco solution is calling into the runtime WASM from the guest WIT-WASM; because the former doesn't have WIT bindings, there's no convenient way to call into it without inventing a WIT-like scheme to request operations from the runtime. (i.e. all you would have available are the C ABI function calls for WASM, and not the full WIT interface, so that layer gets very gnarly)</p>\n<p>I can't think of a nice way around this that wouldn't involve a lot of manual maintenance, or writing our own WIT-like solution... and if the latter's necessary, it might be better to build actual WIT bindgen for this scenario. Just not sure about relative efforts.</p>",
        "id": 370538254,
        "sender_full_name": "Philpax",
        "timestamp": 1687977443
    },
    {
        "content": "<p>Hello <span class=\"user-mention\" data-user-id=\"515290\">@Philpax</span>, I am also working on a hobby video game in Rust that loads WASM modules (now wit components), and I also want to make it work on the web. I have created a new crate for this purpose, called <a href=\"https://github.com/kajacx/wasm-bridge\">wasm-bridge</a>.</p>\n<p>The goal is to \"make wasmtime work on the web\", the implementation is to provide the same API as the wasmtime rust crate, but use js-sys instead on the web. The only two implemented features are calling an exported function, and importing a function.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/kajacx/wasm-bridge\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/9dbb6fe9f01a81e332b7a13addcbaceea3d4a0f5\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f623433366230626337346561346435666636306162356165383364663136633239323333353933376539613635613332316265373338333832613938376239302f6b616a6163782f7761736d2d627269646765)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/kajacx/wasm-bridge\" title=\"GitHub - kajacx/wasm-bridge: Proves a sigle unified API to run WASM modules on the dektop using wasmtime, or on the web using js-sys.\">GitHub - kajacx/wasm-bridge: Proves a sigle unified API to run WASM modules on the dektop using wasmtime, or on the web using js-sys.</a></div><div class=\"message_embed_description\">Proves a sigle unified API to run WASM modules on the dektop using wasmtime, or on the web using js-sys. - GitHub - kajacx/wasm-bridge: Proves a sigle unified API to run WASM modules on the dektop ...</div></div></div>",
        "id": 371745290,
        "sender_full_name": "Karel Hrkal (kajacx)",
        "timestamp": 1688309041
    },
    {
        "content": "<p>What's more interesting is wit-bindgen / component model support. I am excited to say that I have a minimal possible example of \"wit bindgen working on the web\", where your code in rust defines imports, loads a wasm component and runs it ON THE WEB.</p>\n<p>You can check out the <code>wit-bindgen</code> branch in <a href=\"https://github.com/kajacx/wasm-playground/tree/wit-bindgen\">this repo</a>, but the code is an absolute mess.</p>\n<p>The reason I am mentioning this is because I wanted to start working on adding component-model support to wasm-bridge, and I was looking to see if there are other people who would find it useful.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/kajacx/wasm-playground/tree/wit-bindgen\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b4537c76ff72a9a422892ba16537c87a11a28fe3\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353735333536656563356263346461623263373336633165636533353633373436393863646231613937353133393430343338646632353131363165376364632f6b616a6163782f7761736d2d706c617967726f756e64)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/kajacx/wasm-playground/tree/wit-bindgen\" title=\"GitHub - kajacx/wasm-playground at wit-bindgen\">GitHub - kajacx/wasm-playground at wit-bindgen</a></div><div class=\"message_embed_description\">Various projects related to WASM, each in it's own branch, so that I don't have 50 repositories. - GitHub - kajacx/wasm-playground at wit-bindgen</div></div></div>",
        "id": 371746193,
        "sender_full_name": "Karel Hrkal (kajacx)",
        "timestamp": 1688309263
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"621586\">@Karel Hrkal</span>! That's awesome, that's more or less exactly what we need. It looks like it's still early days, but it's promising. What's your estimation of the complexity of the task?</p>\n<p>I was looking at taking the existing wasmtime bindgen and decoupling it from wasmtime, then trying to hook up a <code>js-sys</code> backend to it. My concern is that there's a lot of work involved in capturing the nuances of the WIT ABI, especially as it's still somewhat of a moving target, so it's easier to start from something that already works. It'd also make it easier to reuse the same traits between <code>wasmtime</code> and <code>js-sys</code> for the actual bindings.</p>\n<p>What do you think of the scope of the problem?</p>",
        "id": 372003719,
        "sender_full_name": "Philpax",
        "timestamp": 1688390355
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"515290\">@Philpax</span> Making wit bindgen work with the component model will definitely be challenging. There are several approaches that I could take, but currently I am thinking this:</p>\n<p><strong>Incompatible API</strong></p>\n<p>Give up on making the component api 1:1 compatible with wasmtime's. Lot of the code using the API is generated from the \"generate!\" macro anyway, so the macro could generate different code on the js target and the user would not know the difference anyway.</p>\n<p>The bigger problem is that some changes will have to affect the user. For example, loading a component and instantiating a component will require different signature <em>and will be asynchronous</em>. This is kind of bad, but honestly, I do not know a way around it. It's because how the jco transpiled modules are loaded.</p>\n<p>The only bright side is that this will be \"temporary\", once component model is supported in the browser (and node, etc), the API can be unified where you load a component from it's bytes.</p>\n<p><strong>Generating the bindgen</strong></p>\n<p>Other than that, it should be possible to make the API identical. Most importantly, implementing the ImportObject, calling exported functions on an instance, and generating the used types.</p>\n<p>This will definitely be a lot of work, but it might be possible to copy the existing macro and slightly edit it's output instead of re-implementing it from the ground up. I will have to see how it goes once I get there.</p>",
        "id": 372078352,
        "sender_full_name": "Karel Hrkal (kajacx)",
        "timestamp": 1688403816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"621586\">@Karel Hrkal</span> in case you haven't seen it yet, the <a href=\"https://github.com/bytecodealliance/jco\">jco toolchain</a> supports running Wasm Components in any JS environment, including web browsers. That's of course not the same as implementing the Wasmtime API in JS, but in general that shouldn't be necessary, since Components aren't meant to be tied to a specific runtime environment</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/jco\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/ef3103cdd90f8448edbd972069fd561aa035d698\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323432373363333637306439393330616635343436396631393836643631303033666536386235373333653936373436386165653034336666383439633839342f62797465636f6465616c6c69616e63652f6a636f)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/jco\" title=\"GitHub - bytecodealliance/jco: JavaScript tooling for working with WebAssembly Components\">GitHub - bytecodealliance/jco: JavaScript tooling for working with WebAssembly Components</a></div><div class=\"message_embed_description\">JavaScript tooling for working with WebAssembly Components - GitHub - bytecodealliance/jco: JavaScript tooling for working with WebAssembly Components</div></div></div>",
        "id": 372150532,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1688430139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234973\">Till Schneidereit</span> <a href=\"#narrow/stream/223391-wasm/topic/.5BAlternatives.20to.5D.20Running.20wasmtime.20on.20the.20web/near/372150532\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"621586\">Karel Hrkal</span> ... the <a href=\"https://github.com/bytecodealliance/jco\">jco toolchain</a> supports running Wasm Components in any JS environment, including web browsers ...</p>\n</blockquote>\n<p>Thanks. I am using jco to run wasm components on the web. when it comes to <em>implementing the Wasmtime API in JS</em>, that's not exactly what I'm trying to do. I want to implement the wasmtime's API in <em>Rust</em>, and have the code compile to WebAssembly so that it can run in the browser.</p>",
        "id": 372206593,
        "sender_full_name": "Karel Hrkal (kajacx)",
        "timestamp": 1688455618
    },
    {
        "content": "<p>The rust code will load the transpiled-by-jco component on the web the same way you would load it from JS using js-sys, but doing it with the same interface as wasmtime's will be the challange. But I have an idea on how to make loading the module and instantiating it <em>synchronous</em>.</p>",
        "id": 372213711,
        "sender_full_name": "Karel Hrkal (kajacx)",
        "timestamp": 1688457501
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"621586\">@Karel Hrkal</span> Yup, that's definitely a conundrum. We're already using the async bindgen for wasmtime because wasmtime's wasi-preview2 is currently async-only, so component instantiation is already async (...that we block on with <code>pollster</code>), but the rest should be fine.</p>\n<p>Agreed on the bindgen - I think the interface should be mostly identical after that, so it shouldn't be too much of a problem from the user's perspective.</p>\n<p>The main issue I see is calling back _into_ the host from the guest - host to guest calls aren't too bad, you just need to prime the WIT ABI state and call the function, but I'm not sure what calling a host function would look like. If it's orchestrated entirely from within Rust, it might be possible to do the same kind of WIT ABI state setup and then calling the relevant host function. It gets more complicated if it exits the host's execution context while executing (i.e. <code>guest.exec()</code> leaves the host WASM, so that you cannot call functions inside of it.)</p>\n<p>I think this might especially be an issue with JCO, because you can't make a component out of the host WASM, so you have no way to communicate back to the host through JCO alone.</p>\n<p>Did you have anything in mind for calling host functions from the guest?</p>",
        "id": 372320408,
        "sender_full_name": "Philpax",
        "timestamp": 1688479277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515290\">Philpax</span> <a href=\"#narrow/stream/223391-wasm/topic/.5BAlternatives.20to.5D.20Running.20wasmtime.20on.20the.20web/near/372320408\">said</a>:</p>\n<blockquote>\n<p>It gets more complicated if it exits the host's execution context while executing (i.e. <code>guest.exec()</code> leaves the host WASM, so that you cannot call functions inside of it.)</p>\n</blockquote>\n<p>I'm not sure what you mean. The host calls an exported function on the plugin, and the plugin calls an imported function from the host, so the execution is now is the host, which itself runs in wasm. I guess you <em>could</em> call into JS code from the imported function, is this what you meant by \"code execution leaving the host wasm\"?</p>\n<p>If so, then there shouldn't be any problem, since that JS code cannot interact with the (jco transpiled) wit component, because it would be loaded elsewhere. The JS code execution would finish, then the execution would return to the host imported function, and then to the plugin, and finally back to the host where you called the exported function.</p>\n<blockquote>\n<p>Did you have anything in mind for calling host functions from the guest?</p>\n</blockquote>\n<p>Yes. <code>wasm-bridge</code> already supports imported functions, see <a href=\"https://github.com/kajacx/wasm-bridge/blob/master/tests/no_bindgen/imported_functions/host.rs\">imported functions tests</a>, but it's for \"normal\" modules, not wit components.</p>\n<p>When it comes to wit components, there are two options that I'm considering:<br>\n1) Read the value's content with Reflect<br>\n2) Convert the value to string with json</p>\n<p>The idea on how the first option can work is <a href=\"https://github.com/kajacx/wasm-playground/blob/d602e7410cbd0cf4503e8d7cfc19d8e01b52751c/runtime-rust-web/src/lib.rs#L43\">here</a>, but a better way would of course be to generate code that converts the <code>JsValue</code>to <code>Point</code>, and then give it to the user instead of making them use <code>JsValue</code>.</p>\n<p>The second option would definitely be easier, JS has built-in JSON support and in Rust you can easily derive (de)serialize with serde. The only issue would be to make sure that the wit -&gt; jco -&gt; Json.serialize path makes the same json as wit -&gt; rust -&gt; serde.serialize would. I would have to try it and see.</p>\n<p>That's the issue with converting values both in imported functions and exported functions, both parameters and results.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/kajacx/wasm-bridge/blob/master/tests/no_bindgen/imported_functions/host.rs\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/4652c3c58ccdfb82b9aa034fc1c7e32fb7e2d5cd\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f393139343737646232373862373130626363626664623061356464396537306565333962623830356438643434363034623438663337623562323930323230372f6b616a6163782f7761736d2d627269646765)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/kajacx/wasm-bridge/blob/master/tests/no_bindgen/imported_functions/host.rs\" title=\"wasm-bridge/tests/no_bindgen/imported_functions/host.rs at master · kajacx/wasm-bridge\">wasm-bridge/tests/no_bindgen/imported_functions/host.rs at master · kajacx/wasm-bridge</a></div><div class=\"message_embed_description\">Proves a single unified API to run WASM modules on the dektop using wasmtime, or on the web using js-sys. - wasm-bridge/tests/no_bindgen/imported_functions/host.rs at master · kajacx/wasm-bridge</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/kajacx/wasm-playground/blob/d602e7410cbd0cf4503e8d7cfc19d8e01b52751c/runtime-rust-web/src/lib.rs#L43\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b4537c76ff72a9a422892ba16537c87a11a28fe3\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353735333536656563356263346461623263373336633165636533353633373436393863646231613937353133393430343338646632353131363165376364632f6b616a6163782f7761736d2d706c617967726f756e64)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/kajacx/wasm-playground/blob/d602e7410cbd0cf4503e8d7cfc19d8e01b52751c/runtime-rust-web/src/lib.rs#L43\" title=\"wasm-playground/runtime-rust-web/src/lib.rs at d602e7410cbd0cf4503e8d7cfc19d8e01b52751c · kajacx/wasm-playground\">wasm-playground/runtime-rust-web/src/lib.rs at d602e7410cbd0cf4503e8d7cfc19d8e01b52751c · kajacx/wasm-playground</a></div><div class=\"message_embed_description\">Various projects related to WASM, each in it&#39;s own branch, so that I don&#39;t have 50 repositories. - wasm-playground/runtime-rust-web/src/lib.rs at d602e7410cbd0cf4503e8d7cfc19d8e01b52751c · ...</div></div></div>",
        "id": 372344401,
        "sender_full_name": "Karel Hrkal (kajacx)",
        "timestamp": 1688483584
    },
    {
        "content": "<blockquote>\n<p>I'm not sure what you mean. The host calls an exported function on the plugin, and the plugin calls an imported function from the host, so the execution is now is the host, which itself runs in wasm. I guess you could call into JS code from the imported function, is this what you meant by \"code execution leaving the host wasm\"?</p>\n</blockquote>\n<p>Ah okay, sounds good. My concern was that the nature of the bridging code (i.e. maybe having to exit out to JS to call the JCO component) would lead to the host not being accessible to call back into, but it doesn't sound like that's a problem. Ignore this :) </p>\n<blockquote>\n<p>Yes. wasm-bridge already supports imported functions, see imported functions tests, but it's for \"normal\" modules, not wit components.</p>\n</blockquote>\n<p>Fantastic! Great work - having that work is already a great proof of concept.</p>\n<blockquote>\n<p>When it comes to wit components, there are two options that I'm considering:<br>\n1) Read the value's content with Reflect<br>\n2) Convert the value to string with json</p>\n<p>The idea on how the first option can work is here, but a better way would of course be to generate code that converts the JsValue to Point, and then give it to the user instead of making them use JsValue.</p>\n<p>The second option would definitely be easier, JS has built-in JSON support and in Rust you can easily derive (de)serialize with serde. The only issue would be to make sure that the wit -&gt; jco -&gt; Json.serialize path makes the same json as wit -&gt; rust -&gt; serde.serialize would. I would have to try it and see.</p>\n<p>That's the issue with converting values both in imported functions and exported functions, both parameters and results.</p>\n</blockquote>\n<p>Hmm... yeah, that's a frustrating problem. I'd go for the JSON route for now and see what happens. That was one of my concerns with using JCO - going through JavaScript would result in some semantic munging - but it's likely the fastest way to get what we want.</p>\n<p>Do you know what happens with values that can't be represented in pure JS/JSON (e.g. <code>u64</code>s and such)? Will JCO round them to the nearest value representable in a <code>f64</code>, or will it use a string?</p>\n<p>In an ideal world, we'd do all the interop ourselves, but that would require an implementation of the WIT ABI, which is (probably) non-trivial. (Would appreciate any insight anyone has into this!)</p>\n<hr>\n<p>Is there anything we can do to help you with this? Figuring out a solution for WASM-on-WASM-on-web is important to us, so just let us know if there's any kind of assistance we can provide.</p>",
        "id": 372363398,
        "sender_full_name": "Philpax",
        "timestamp": 1688487555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515290\">Philpax</span> <a href=\"#narrow/stream/223391-wasm/topic/.5BAlternatives.20to.5D.20Running.20wasmtime.20on.20the.20web/near/372363398\">said</a>:</p>\n<blockquote>\n<p>what happens with values that can't be represented in pure JS/JSON (e.g. u64s and such)?</p>\n</blockquote>\n<p><code>i64</code> is represented as <code>BigInt</code> when loading a \"normal\" module, I'm confident JCO does the same thing. When it comes to converting <code>BigInt</code> to JSON ...</p>\n<div class=\"codehilite\" data-code-language=\"JavaScript\"><pre><span></span><code><span class=\"nb\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"mi\">100n</span><span class=\"p\">)</span>\n<span class=\"nx\">Uncaught</span><span class=\"w\"> </span><span class=\"ne\">TypeError</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nb\">BigInt</span><span class=\"w\"> </span><span class=\"nx\">value</span><span class=\"w\"> </span><span class=\"nx\">can</span><span class=\"err\">'</span><span class=\"nx\">t</span><span class=\"w\"> </span><span class=\"nx\">be</span><span class=\"w\"> </span><span class=\"nx\">serialized</span><span class=\"w\"> </span><span class=\"ow\">in</span><span class=\"w\"> </span><span class=\"nb\">JSON</span>\n</code></pre></div>\n<p>So there goes that idea. Another option might be to use wasm-bindgen and their bindings, but I have not really managed to get that to work. So adding a custom derive-able trait for (de)serialization via the Reflect method might be the way forward.</p>\n<blockquote>\n<p>Is there anything we can do to help you with this? Figuring out a solution for WASM-on-WASM-on-web is important to us, so just let us know if there's any kind of assistance we can provide.</p>\n</blockquote>\n<p>Thanks! I can start by showing you what I got with shared screen on discord, feel free to join here: <a href=\"https://discord.gg/VTPDUkmX\">https://discord.gg/VTPDUkmX</a><br>\nThen we can discuss on how to move forward.</p>",
        "id": 372380164,
        "sender_full_name": "Karel Hrkal (kajacx)",
        "timestamp": 1688492277
    }
]