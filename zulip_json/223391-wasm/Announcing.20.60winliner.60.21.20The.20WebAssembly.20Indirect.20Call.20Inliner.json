[
    {
        "content": "<p><a href=\"https://github.com/fitzgen/winliner\">https://github.com/fitzgen/winliner</a></p>\n<p><a href=\"https://crates.io/crates/winliner\">https://crates.io/crates/winliner</a></p>\n<p><a href=\"https://docs.rs/winliner/latest/winliner/\">https://docs.rs/winliner/latest/winliner/</a></p>\n<blockquote>\n<p>Winliner speculatively inlines indirect calls in WebAssembly, based on observed information from a previous profiling phase. This is a form of profile-guided optimization that we affectionately call winlining.</p>\n<p>First, Winliner inserts instrumentation to observe the actual target callee of every indirect call site in your Wasm program. Next, you run the instrumented program for a while, building up a profile. Finally, you invoke Winliner again, this time providing it with the recorded profile, and it optimizes your Wasm program based on the behavior observed in that profile.</p>\n</blockquote>\n<p>Similar to Wizer, the wins you get from this tool are going to be very dependent on your exact workload. How bottlenecked are you on indirect calls? And how monomorphic are those indirect calls in practice?</p>\n<p>Some very very very preliminary results for <code>spidermonkey.wasm</code> show octane's richards benchmark (which happens to be the only benchmark I have on hand) going from <code>141</code> to <code>232</code> (higher is better) for a speed up of <code>1.65x</code>!</p>\n<p>So, give Winliner a try and let me know if you run into any bugs or see any fun results!</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/fitzgen/winliner\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/0d6b7f363bce7d2f73784b18ed7ae4c3697aa56b\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313537383761633732623830366434636330646232636466366665613061393839643364326332393962373238623038326363633037356133643065386565362f6669747a67656e2f77696e6c696e6572)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/fitzgen/winliner\" title=\"GitHub - fitzgen/winliner: The WebAssembly Indirect Call Inliner\">GitHub - fitzgen/winliner: The WebAssembly Indirect Call Inliner</a></div><div class=\"message_embed_description\">The WebAssembly Indirect Call Inliner. Contribute to fitzgen/winliner development by creating an account on GitHub.</div></div></div>",
        "id": 397152778,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1697563323
    },
    {
        "content": "<blockquote>\n<p>Some very very very preliminary results for spidermonkey.wasm show octane's richards benchmark (which happens to be the only benchmark I have on hand) going from 141 to 232 (higher is better) for a speed up of 1.65x!</p>\n</blockquote>\n<p>Important clarification for folks -- that's on a test case that has ICs added/generated by some (not yet released) tooling with PBL and weval; the speedup comes from inlining the ICs. In other words the case was full of just-ready-to-be-inlined code. Unfortunately this speedup isn't as likely to come from arbitrary inlining on general programs (though we hypothesize C++ vtables might give some opportunity elsewhere!)</p>",
        "id": 397183129,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1697577346
    }
]