[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> hey some questions about the module-types explainer</p>",
        "id": 197957086,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818124
    },
    {
        "content": "<p>I think we'll probably want a separate index space for each kind of type, right?</p>",
        "id": 197957120,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818142
    },
    {
        "content": "<p>like right now we only have the \"type index space\", but that's more realistically the \"function type index space\"</p>",
        "id": 197957149,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818153
    },
    {
        "content": "<p>and module types are adding 2 more index spaces, the module types and instance types index space</p>",
        "id": 197957170,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818163
    },
    {
        "content": "<p>does that sound right?</p>",
        "id": 197957183,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818170
    },
    {
        "content": "<p>Yup, index space per type.  In MVP wasm we have have 5 index spaces (type, function, table, memory, global), and Module Linking would add 2 more (module and instance)</p>",
        "id": 197957971,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818499
    },
    {
        "content": "<p>technically it's 4 more?</p>",
        "id": 197958040,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818530
    },
    {
        "content": "<p>the \"type\" index space will grow to contain not just function typedefs, but also module typedefs, instance typedefs, and later GC typedefs</p>",
        "id": 197958041,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818531
    },
    {
        "content": "<p>er</p>",
        "id": 197958044,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818534
    },
    {
        "content": "<p>yeah so I may be confused about this type index space</p>",
        "id": 197958068,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818547
    },
    {
        "content": "<p>if I define one function, one module, and one instance type, all three indices are zero?</p>",
        "id": 197958157,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818563
    },
    {
        "content": "<p>or indices are 0, 1, 2?</p>",
        "id": 197958173,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818568
    },
    {
        "content": "<p>the indices for the type that is</p>",
        "id": 197958193,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818579
    },
    {
        "content": "<p>(I thought this was adding 4 index spaces, {module, instance} x {type, def})</p>",
        "id": 197958229,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818597
    },
    {
        "content": "<p>and I thought the existing \"type\" index space was going to be basically renamed to \"function type\" index space</p>",
        "id": 197958280,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818618
    },
    {
        "content": "<p>in that situation you have 4 index spaces at play: a type index space with 3 types (0,1,2), and then single-element module index space (which <em>defines</em> the module, but also refers to the module's type in the type index space), and similarly a single-element instance and function index space</p>",
        "id": 197958296,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818625
    },
    {
        "content": "<p>hm so the I can declare a module with a function type (erroneously)</p>",
        "id": 197958360,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818657
    },
    {
        "content": "<p>and that'd have to be caught in validation?</p>",
        "id": 197958370,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818661
    },
    {
        "content": "<p>where the type of a module is indeed a module type?</p>",
        "id": 197958389,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818667
    },
    {
        "content": "<p>correct</p>",
        "id": 197958395,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818671
    },
    {
        "content": "<p>why not have separate index spaces though?</p>",
        "id": 197958417,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818677
    },
    {
        "content": "<p>like one index space per type</p>",
        "id": 197958466,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818685
    },
    {
        "content": "<p>fwiw, this \"type\" vs. \"declaration of a function's type\" distinction is already started in the MVP: <a href=\"https://webassembly.github.io/spec/core/syntax/modules.html#indices\">https://webassembly.github.io/spec/core/syntax/modules.html#indices</a></p>",
        "id": 197958475,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818689
    },
    {
        "content": "<p>well, the type section is all incestuously circular</p>",
        "id": 197958529,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818712
    },
    {
        "content": "<p>(in the limit, once we have first-class references to all the things)</p>",
        "id": 197958584,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818740
    },
    {
        "content": "<p>but that's still allowed with multiple index spaces?</p>",
        "id": 197958586,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818740
    },
    {
        "content": "<p>so you have this one index space of \"type definitions\" where all the types can refer to each other</p>",
        "id": 197958609,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818752
    },
    {
        "content": "<p>oh you're thinking like \"here's the N types of this module\", and you verify all sub-indices are less than N ?</p>",
        "id": 197958617,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818756
    },
    {
        "content": "<p>and then all the other definitions can point into it</p>",
        "id": 197958631,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818759
    },
    {
        "content": "<p>I was imagining we'd still have just one type section, but it'd add to each respective index space depending on what's defined</p>",
        "id": 197958693,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818789
    },
    {
        "content": "<p>sort of like the import section</p>",
        "id": 197958706,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818795
    },
    {
        "content": "<p>but because types refer to each other we can't validate until everything is parsed</p>",
        "id": 197958767,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818805
    },
    {
        "content": "<p>and we'd rather validate in a streaming fashion?</p>",
        "id": 197958777,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818810
    },
    {
        "content": "<p>well, \"everything is parsed\" as in \"the type section is fully parsed\"</p>",
        "id": 197958819,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818827
    },
    {
        "content": "<p>yeah, in general, the type section will have to be validated all-at-once</p>",
        "id": 197958871,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818846
    },
    {
        "content": "<p>b/c, eventually at least, it'll be circular</p>",
        "id": 197958903,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589818858
    },
    {
        "content": "<p>hm wait then I still don't understand why we wouldn't have a separate index space for each class of types</p>",
        "id": 197958950,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818873
    },
    {
        "content": "<p>if we assume you parse the whole type section, then you validate the whole thing</p>",
        "id": 197958987,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589818884
    },
    {
        "content": "<p>incidentally, i'm polishing up a change to the \"Binary Format Considerations\" section of the Module Linking PR which explains that we actually need to loosen up the section rules a bit so that you can split up and interleave the Type, Import, Module, Function and Alias Sections.  The reason being that there is no longer a simple ordering of sections that prevents forward references.  So rather, you can just have \"some types\" then \"some modules\" then ....  and the index spaces grow monotonically, and validation is just relative to the current index space contents</p>",
        "id": 197959312,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819008
    },
    {
        "content": "<p>(answering why not a separate index space per class of type:) i think that could be an isomorphic alternative; you'd basically have to put the \"what class of type is this\" next to the index.  with the current design (already in the MVP), the \"what class of type is this\" enum is part of the typedef itself</p>",
        "id": 197959478,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819074
    },
    {
        "content": "<p>Isn't the index space of the index specified always implicit though?</p>",
        "id": 197959591,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819126
    },
    {
        "content": "<p>e.g. <code>call_indirect</code> always looks up in the function type index space, not the module type index space</p>",
        "id": 197959610,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819136
    },
    {
        "content": "<p>and module declarations would be relative to the module type index space</p>",
        "id": 197959638,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819148
    },
    {
        "content": "<p>right, but if you have a (ref $typeindex)...</p>",
        "id": 197959642,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819149
    },
    {
        "content": "<p>that's an index in <em>the</em> type section</p>",
        "id": 197959653,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819156
    },
    {
        "content": "<p>wouldn't that be relative to the \"w/e the reference types index space\" is?</p>",
        "id": 197959688,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819163
    },
    {
        "content": "<p>could be to a function or module or instance ...</p>",
        "id": 197959706,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819164
    },
    {
        "content": "<p>hm ok, I basically know no context about gc</p>",
        "id": 197959765,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819186
    },
    {
        "content": "<p>so $typeindex is (eventually) one of {function, struct, array, module, instance, ...}, which isn't a reference to the thing, but the thing itself</p>",
        "id": 197959858,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819224
    },
    {
        "content": "<p>and (ref $typeindex) is building a <em>new</em> type, which is a reference to the thing</p>",
        "id": 197959881,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819238
    },
    {
        "content": "<p>not sure I fully understand but \"wave hands gc changes things\" is good enough for me for now</p>",
        "id": 197959960,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819277
    },
    {
        "content": "<p>a different example, in interface types-land is when you have (record (field \"x\" $sometype))</p>",
        "id": 197960030,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819291
    },
    {
        "content": "<p>$sometype could be one of several different \"classes\" of type</p>",
        "id": 197960061,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819305
    },
    {
        "content": "<p>(in this case there's no reference, it's just a record value embedding some other value as a field)</p>",
        "id": 197960100,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819322
    },
    {
        "content": "<p>it's ok, I'll just take this as a given for now :)</p>",
        "id": 197960294,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819392
    },
    {
        "content": "<p>FWIW, if you look at the binary encoding of function types (<a href=\"https://webassembly.github.io/spec/core/binary/types.html#function-types\">https://webassembly.github.io/spec/core/binary/types.html#function-types</a>), the first byte, 0x60, is the \"what class of typedef is this\" byte</p>",
        "id": 197960378,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819408
    },
    {
        "content": "<p>it's just explicitly called out b/c there is currently only one class of typedef</p>",
        "id": 197960417,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819420
    },
    {
        "content": "<p>right yeah, so more types fits well</p>",
        "id": 197960507,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819455
    },
    {
        "content": "<p>but it is carefully chosen to be distinct from every other type code: <a href=\"https://searchfox.org/mozilla-central/source/js/src/wasm/WasmConstants.h#63\">https://searchfox.org/mozilla-central/source/js/src/wasm/WasmConstants.h#63</a></p>",
        "id": 197960513,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819458
    },
    {
        "content": "<p>I just don't fully understand how gc changes things to require one index space as opposed to multiple type index spaces</p>",
        "id": 197960546,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819470
    },
    {
        "content": "<p>well even now we only have 1 type index space</p>",
        "id": 197960570,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819482
    },
    {
        "content": "<p>I know yeah, but I don't know why we wouldn't want more with this proposal</p>",
        "id": 197960589,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819494
    },
    {
        "content": "<p>the \"function\" index space isn't a space of types, it's a space of function definitions</p>",
        "id": 197960590,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819494
    },
    {
        "content": "<p>right yeah, but with module types I don't know why we don't rename the type index space to \"function type\" index space</p>",
        "id": 197960648,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819522
    },
    {
        "content": "<p>you're mentioning because of gc <code>(ref $ty)</code> things, but I don't fully get that, but that's also ok I don't really need to at this point</p>",
        "id": 197960717,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819537
    },
    {
        "content": "<p>i guess b/c we've already planned to have a single index space, discriminating with the 0x60 prefix code</p>",
        "id": 197960732,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819544
    },
    {
        "content": "<p>it just means extra validation rules for type references</p>",
        "id": 197960743,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819548
    },
    {
        "content": "<p>which technically avoids needing to put that discriminator on every use</p>",
        "id": 197960757,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819555
    },
    {
        "content": "<p>in some cases, yes, but in other cases, i think you need the discriminant in one place or the other</p>",
        "id": 197960800,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819578
    },
    {
        "content": "<p>e.g., function definitions can only refer to function types, so yeah, there it's extra checking</p>",
        "id": 197960831,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819593
    },
    {
        "content": "<p>but other cases can reference any type</p>",
        "id": 197960898,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819627
    },
    {
        "content": "<p>it's mostly poTAYto poTAHto though :)</p>",
        "id": 197960981,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819653
    },
    {
        "content": "<p>we've just have established a precedent in one direction</p>",
        "id": 197961004,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589819666
    },
    {
        "content": "<p><em>shrug</em></p>",
        "id": 197961031,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> can you also explain a bit more this <code>alias</code> thing?</p>",
        "id": 197961317,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819791
    },
    {
        "content": "<p>I don't really understand much about it other than \"it can refer to parent stuff\"</p>",
        "id": 197961363,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589819812
    },
    {
        "content": "<p>(sorry meetings)  yeah, <code>alias</code> lets you inject a definition in either (1) your parent, (2) the export of an imported or nested instance</p>",
        "id": 197964573,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589821227
    },
    {
        "content": "<p>I'll post an update to the PR later today</p>",
        "id": 197964608,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589821250
    },
    {
        "content": "<p>mk I'll wait for that</p>",
        "id": 197964871,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589821372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> <a href=\"https://github.com/WebAssembly/module-types/pull/3/commits/73950e7f977fc601107b4bdc5058389772cd8d45\">https://github.com/WebAssembly/module-types/pull/3/commits/73950e7f977fc601107b4bdc5058389772cd8d45</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/module-types/pull/3/commits/73950e7f977fc601107b4bdc5058389772cd8d45\" style=\"background-image: url(https://avatars1.githubusercontent.com/u/9660325?s=400&amp;v=4)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/module-types/pull/3/commits/73950e7f977fc601107b4bdc5058389772cd8d45\" title=\"Generalize Module Types to Module Linking by lukewagner · Pull Request #3 · WebAssembly/module-types\">Generalize Module Types to Module Linking by lukewagner · Pull Request #3 · WebAssembly/module-types</a></div><div class=\"message_embed_description\">As is, the Module Types proposal tweaks the spec-internal definition of module/instance types and gives them a text format so that module/instance types can be used in toolchains, but there are no ...</div></div></div>",
        "id": 198005684,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589842674
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> can you give an example of what you're thinking with an <code>alias</code> referring to something in the enclosing module?</p>",
        "id": 198008372,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589845274
    },
    {
        "content": "<p>It also feels a bit odd to have so many alias/instance sections, do you think it'd be possible to fold alias definitions into the instance section? The same idea just a different binary structure where the instance section would be a bit more \"meaty\". Each element in the instance section would either instantiate a module or create an alias for a previous instance.</p>",
        "id": 198008573,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589845465
    },
    {
        "content": "<p>eh maybe not, you have to alias imports as well... anyway</p>",
        "id": 198008593,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589845490
    },
    {
        "content": "<p>So the intention is that <code>(alias $name (func $instance $fname))</code> -- <code>$name</code> is the name of the function we're creating (optional), <code>$instance</code> is an instance index, and <code>$fname</code>, is that encoded as <code>\"fname\"</code> the string or an index where it's the nth exported function (or nth export?) of <code>$instance</code>?</p>",
        "id": 198008702,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589845610
    },
    {
        "content": "<p>For the first question: the reason for aliases referring to the outer module is just to remove redundancy; in package linking scenarios, the same module/instance types get repeated a ton.</p>",
        "id": 198010283,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589847349
    },
    {
        "content": "<p>For the second: yeah, that was the alternative I liked for a while.  The thing that's a bit odd about it is that an alias in the instance section doesn't add a new kind of instance, so it's not really the \"instance\" section but the \"instance and alias of instance exports\" section.  Aliases are a bit like Imports, so it seems vaguely symmetric to give them their own section.  But it's not like that's the only way to do it.</p>",
        "id": 198010640,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589847691
    },
    {
        "content": "<p>For the third: yes, that's right.  $fname is an index into the exports array of $instance's type definition (which is local tot he module)</p>",
        "id": 198010653,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589847718
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> oh referring to the parent makes sense, I was wondering if you had thoughts on the binary format? If aliases can only refer to exports you can't define exports before instantiating right? I'm just murky on how the specifics of semantics and binary encoding would work</p>",
        "id": 198016799,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589855429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span>   Aliases can refer to any type/module defs in the parents' index spaces, not just exports.  It's only aliases to nested instances that can only refer to exports</p>",
        "id": 198018739,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589858799
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> ok so here's what I've got so far, mind skimming it over and see if I misinterpreted or am missing anything? -- <a href=\"https://gist.github.com/alexcrichton/506ac6d2f7d505d556d68fb969489183\">https://gist.github.com/alexcrichton/506ac6d2f7d505d556d68fb969489183</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://gist.github.com/alexcrichton/506ac6d2f7d505d556d68fb969489183\" style=\"background-image: url(https://github.githubassets.com/images/modules/gists/gist-og-image.png)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://gist.github.com/alexcrichton/506ac6d2f7d505d556d68fb969489183\" title=\"new-binary-2.md\">new-binary-2.md</a></div><div class=\"message_embed_description\">GitHub Gist: instantly share code, notes, and snippets.</div></div></div>",
        "id": 198090841,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589905329
    },
    {
        "content": "<p>Looking at importdesc, one could reconsider the existing 0x00 case from always being a func to instead being \"whatever the indexed type is\", so that as soon as you add module/instance types, the 0x00 can refer to them just as well as func.  E.g., that's what (ref $typeIndex) will do</p>",
        "id": 198092293,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589905965
    },
    {
        "content": "<p>But actually, that's super-bikeshed-y, so n/m</p>",
        "id": 198092423,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906028
    },
    {
        "content": "<p>Different, but perhaps-more-justifiable bikeshed: in the Alias section, for the <code>parent</code> aliases, could the second byte of module be 0x04 (to match import and export)?</p>",
        "id": 198093141,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906335
    },
    {
        "content": "<p>oh sure</p>",
        "id": 198093341,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906414
    },
    {
        "content": "<p>although you may be able to help me clarify that</p>",
        "id": 198093352,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906422
    },
    {
        "content": "<p>when you refer toy your parent's index</p>",
        "id": 198093363,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906426
    },
    {
        "content": "<p>that's indexing within your parent's module index space, right? not your parent's export index space?</p>",
        "id": 198093390,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906444
    },
    {
        "content": "<p>correctamundo</p>",
        "id": 198093446,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906468
    },
    {
        "content": "<p>ok yeah I can change the alignment</p>",
        "id": 198093476,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906488
    },
    {
        "content": "<p>also great idea with using <code>(parent $x)</code> as the text format, i'm going to update the Explainer to match</p>",
        "id": 198093499,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906498
    },
    {
        "content": "<p>I do want to document the text form at as well, but I'll probably do that in tandem with writing the text parser</p>",
        "id": 198093650,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906547
    },
    {
        "content": "<p>One other tweak: in components, I think there aren't any Table, Memory or Global sections allowed, so perhaps you can explicitly say these are disallowed</p>",
        "id": 198093679,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906566
    },
    {
        "content": "<p>table/global makes sense, but for memory, do you mean no defined memory, but you can still import memory, right?</p>",
        "id": 198093751,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906601
    },
    {
        "content": "<p>(e.g. <code>string.lift</code> needs an index space to operate on)</p>",
        "id": 198093783,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906612
    },
    {
        "content": "<p>yes, you can still <em>alias</em> all of the memories/tables/globals of nested instances</p>",
        "id": 198093913,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906658
    },
    {
        "content": "<p>ah ok, so you still have an index space, just no local definitions</p>",
        "id": 198093950,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906673
    },
    {
        "content": "<p>makes sense</p>",
        "id": 198093962,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906681
    },
    {
        "content": "<p>one last change: i think, unlike the core section rules, we can allow the Function section to be intermingled with the Instance/Module/Type sections</p>",
        "id": 198094098,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906746
    },
    {
        "content": "<p>so that adapter functions can be imported by nested instances</p>",
        "id": 198094174,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906771
    },
    {
        "content": "<p>only for components, though?</p>",
        "id": 198094227,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906796
    },
    {
        "content": "<p>correct</p>",
        "id": 198094248,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906802
    },
    {
        "content": "<p>i thought about it a lot for core modules and i think it needs the stricter separation</p>",
        "id": 198094281,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906818
    },
    {
        "content": "<p>part of what makes it make sense for adapter functions is that component instances are (mostly, get to that in a sec) stateless</p>",
        "id": 198094326,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906836
    },
    {
        "content": "<p>so we can say that the component instance is created <em>before</em> its nested instances</p>",
        "id": 198094341,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906844
    },
    {
        "content": "<p>the one bit of state a component instance has is: which of my nested instances have been created</p>",
        "id": 198094381,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906861
    },
    {
        "content": "<p>but we'd still have the trap-if-you-call-too-early semantics?</p>",
        "id": 198094394,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906867
    },
    {
        "content": "<p>so what we can say is that it is a dynamic error to call an export of an instance that hasn't been created</p>",
        "id": 198094414,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906879
    },
    {
        "content": "<p>and so if a component has nested instances A B and C</p>",
        "id": 198094463,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906887
    },
    {
        "content": "<p>heh yeah that works too</p>",
        "id": 198094466,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589906889
    },
    {
        "content": "<p>then A can call adapter functions which call component imports,</p>",
        "id": 198094507,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906914
    },
    {
        "content": "<p>but if it tries to call into B or C, that'll trap</p>",
        "id": 198094587,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906960
    },
    {
        "content": "<p>there is that subtle detail of are A's exports visible if A's start function calls the adapter function</p>",
        "id": 198094633,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589906981
    },
    {
        "content": "<p>\"meh\"</p>",
        "id": 198094704,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589907003
    },
    {
        "content": "<p>i think for now we can say \"yes\", and then later talk about the \"after start\" function thing later</p>",
        "id": 198094751,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589907031
    },
    {
        "content": "<p>b/c import adapters definitely need to be able to reenter the core module caller, to call malloc()</p>",
        "id": 198094800,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589907059
    },
    {
        "content": "<p>ok updated the gist with this</p>",
        "id": 198094814,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589907065
    },
    {
        "content": "<p><a href=\"https://gist.github.com/alexcrichton/506ac6d2f7d505d556d68fb969489183/revisions#diff-592762304f59428e5070ae1c46ce9859\">https://gist.github.com/alexcrichton/506ac6d2f7d505d556d68fb969489183/revisions#diff-592762304f59428e5070ae1c46ce9859</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://gist.github.com/alexcrichton/506ac6d2f7d505d556d68fb969489183/revisions#diff-592762304f59428e5070ae1c46ce9859\" style=\"background-image: url(https://github.githubassets.com/images/modules/open_graph/github-octocat.png)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://gist.github.com/alexcrichton/506ac6d2f7d505d556d68fb969489183/revisions#diff-592762304f59428e5070ae1c46ce9859\" title=\"Build software better, together\">Build software better, together</a></div><div class=\"message_embed_description\">GitHub is where people build software. More than 50 million people use GitHub to discover, fork, and contribute to over 100 million projects.</div></div></div>",
        "id": 198094884,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589907102
    },
    {
        "content": "<p>ah, i see you're writing to cover <em>both</em> the module and component cases</p>",
        "id": 198094957,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589907122
    },
    {
        "content": "<p>in that case, you might want to add a caveat to the version word noting that the 0x1 is only for components</p>",
        "id": 198095030,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589907143
    },
    {
        "content": "<p>oh sorry yeah this is sort of like a diff of what we expect to land in wasmparser</p>",
        "id": 198095065,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589907161
    },
    {
        "content": "<p>which would parse both</p>",
        "id": 198095071,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589907164
    },
    {
        "content": "<p>anyhow, just wanted to say great job on this!</p>",
        "id": 198095144,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589907201
    },
    {
        "content": "<p>do you mind if i resolve your open conversations in the Module Linking PR?  or happy for you to comment on them</p>",
        "id": 198096634,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589907749
    },
    {
        "content": "<p>oh sorry of course</p>",
        "id": 198096882,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589907860
    },
    {
        "content": "<p>were you waiting on me to do that?</p>",
        "id": 198096902,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589907866
    },
    {
        "content": "<p>or is it expected that I do that?</p>",
        "id": 198096912,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589907870
    },
    {
        "content": "<p>they were resolved like the second you replied weeks ago lol</p>",
        "id": 198096940,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1589907880
    },
    {
        "content": "<p>haha, no worries, i was making progress on other discussions in the PR, so no waiting.  i was just tidying up since it's looking like we're almost done.  i'm still going to present at the next CG meeting before merging, i think</p>",
        "id": 198102984,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589910607
    },
    {
        "content": "<p>well, i dunno</p>",
        "id": 198102992,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589910613
    },
    {
        "content": "<p>btw, i was working through an example with transitive dependencies to see how the link step would work.  my main interest was finding a scheme whereby the generated Linked Module simply imports unmodified Packaged Modules and avoiding the module type of a given Packaged Module needing to capture all of its transitive dependencies in its module type.  i ended up finding a wrapping scheme that uses nested modules and parent aliases to essentially \"curry\" module imports:  <a href=\"https://gist.github.com/lukewagner/d662cbe7b58281672053dab4118d25b7\">https://gist.github.com/lukewagner/d662cbe7b58281672053dab4118d25b7</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://gist.github.com/lukewagner/d662cbe7b58281672053dab4118d25b7\" style=\"background-image: url(https://github.githubassets.com/images/modules/gists/gist-og-image.png)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://gist.github.com/lukewagner/d662cbe7b58281672053dab4118d25b7\" title=\"linked-modules.wat\">linked-modules.wat</a></div><div class=\"message_embed_description\">GitHub Gist: instantly share code, notes, and snippets.</div></div></div>",
        "id": 198105322,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589911657
    },
    {
        "content": "<p>might be an interesting test case ;)</p>",
        "id": 198105479,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1589911713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> here's something to think about:</p>\n<div class=\"codehilite\"><pre><span></span><code>(type $t (instance (export &quot;x&quot; (instance (type $t)))))\n</code></pre></div>",
        "id": 198269004,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016417
    },
    {
        "content": "<p>I think that needs to be an error of some kind</p>",
        "id": 198269017,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016434
    },
    {
        "content": "<p>or something like for the text format we have to figure out a DAG of how to visit type definitions</p>",
        "id": 198269087,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016481
    },
    {
        "content": "<p>I'm assuming we're doing the same thing for instances as we do for functions, which is when you declare the type you can specify both the <code>(type xx)</code> reference as well as the type inline (e.g. <code>(func (type 0) (param i32))</code>)</p>",
        "id": 198269233,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016655
    },
    {
        "content": "<p>but when both are specified, we need to validate they're equal</p>",
        "id": 198269242,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016663
    },
    {
        "content": "<p>(e.g. <code>type 0</code> is indeed <code>(func (param i32))</code>)</p>",
        "id": 198269251,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016671
    },
    {
        "content": "<p>so like I think this is technically valid:</p>\n<div class=\"codehilite\"><pre><span></span><code>(type $t (instance\n  (export &quot;x&quot; (instance (type $t)\n    (export &quot;x&quot; (instance (type $t)\n      (export &quot;x&quot; (instance (type $t)\n        (export &quot;x&quot; (instance (type $t)\n          (export &quot;x&quot; (instance (type $t)\n            (export &quot;x&quot; (instance (type $t)\n            (export &quot;x&quot; (instance (type $t)))\n            ))\n          ))\n        ))\n      ))\n    ))\n  ))\n))\n</code></pre></div>",
        "id": 198269344,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016734
    },
    {
        "content": "<p>but validating that at the text level isn't really easy to do because as we're determining the canonical value for <code>$t</code> we need to know what <code>$t</code> is to compare it to <code>$t</code></p>",
        "id": 198269381,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016773
    },
    {
        "content": "<p>we can perhaps solve this by saying \"don't do the function thing, you say the index or you say the inline, not both\"</p>",
        "id": 198269397,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016794
    },
    {
        "content": "<p>well so let me rephrase, this seems like it could either be a binary error or a text error</p>",
        "id": 198269487,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016856
    },
    {
        "content": "<p>I feel like we want it to be a text error</p>",
        "id": 198269517,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016881
    },
    {
        "content": "<p>I'm getting tripped up in how circularly recursive this is</p>",
        "id": 198269526,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590016891
    },
    {
        "content": "<p>Haha, yes, I think no recursive types for now.  Perhaps just by requiring all type indices refer to earlier typedefs</p>",
        "id": 198272081,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590019157
    },
    {
        "content": "<p>Also, agreed that if you write (instance (type $T)) you shouldn't need to be able to re-state all the exports/imports</p>",
        "id": 198272364,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590019372
    },
    {
        "content": "<p>That's really just a goofy special case for functions so they can assign identifiers to parameters</p>",
        "id": 198272393,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590019398
    },
    {
        "content": "<p>Actually, for directly-embedded type definitions like you're showing, I think no circularity forever; the only exception is circularity via (ref $T)</p>",
        "id": 198272454,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590019440
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> ok sounds good, I'll need to write some sort of sorting pass in the text parser then too to do a topological sort</p>",
        "id": 198273839,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590020645
    },
    {
        "content": "<p>ah, bummer, yes.  for starters you could require text to be in order too ;)</p>",
        "id": 198273911,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590020737
    },
    {
        "content": "<p>thinking more on it, you're right, I think the text format should impose the restriction itself</p>",
        "id": 198275331,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590022157
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> here's another interesting thing to think about, so right now you can specify imports/exports inline in the text format, e.g. these are all the same</p>\n<div class=\"codehilite\"><pre><span></span><code>(func $f)\n(export &quot;&quot; (func $f))\n(func $f (export &quot;&quot;))\n\n(import &quot;&quot; &quot;&quot; (func $f))\n(func $f (import &quot;&quot; &quot;&quot;))\n</code></pre></div>",
        "id": 198385555,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100211
    },
    {
        "content": "<p>for nested modules, however, the proposed syntax you've got so far doesn't support this</p>",
        "id": 198385575,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100222
    },
    {
        "content": "<p>b/c <code>(module ...)</code> the imports/exports would be ambiguous</p>",
        "id": 198385610,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100236
    },
    {
        "content": "<p>or I guess it'd be ambiguous without more lookahead</p>",
        "id": 198385624,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100244
    },
    {
        "content": "<p>I'm wondering if it makes sense to do something like:</p>",
        "id": 198385660,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100259
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>",
        "id": 198385662,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100261
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>(nested-module (type $ty) (module ...))\n</code></pre></div>",
        "id": 198385704,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100277
    },
    {
        "content": "<p>where you can specify inline imports/exports if you want</p>",
        "id": 198385714,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100285
    },
    {
        "content": "<p>and <code>(module ...)</code> bare is sugar for auto-calculating the type, inserting it into the type index space, and not having any implicit imports/exports</p>",
        "id": 198385734,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100303
    },
    {
        "content": "<p>I was also wondering how you'd do something like <code>(module (type $module_type) ...)</code> b/c that's also ambiguous</p>",
        "id": 198385826,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100331
    },
    {
        "content": "<p>but at least for printing the binary format we'll need a way to say \"the module type was specified at this index, don't inject anything else\"</p>",
        "id": 198385858,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590100353
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> sorry, which part was ambiguous?</p>",
        "id": 198386374,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590100676
    },
    {
        "content": "<p>i would think (module ...) would be mostly symmetric to (func ...) in the ways you mentioned (import, export, explicit type index)</p>",
        "id": 198386486,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590100720
    },
    {
        "content": "<p>i see your point that it'd be necessary to scan the whole body of (module ...) to determine the module type, unlike (func ...) which tells you that basically up-front</p>",
        "id": 198386550,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590100765
    },
    {
        "content": "<p>but i think there's still symmetry with func in that, to validate the body of a (func ...), you have to have parsed all the types of all the other functions first (so that you know all the funcs' types)</p>",
        "id": 198386705,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590100845
    },
    {
        "content": "<p>hm ok so I've got two concerns here</p>",
        "id": 198387375,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590101233
    },
    {
        "content": "<p>one is how to parse this:</p>\n<div class=\"codehilite\"><pre><span></span><code>(module\n  (module (export &quot;x&quot;))\n)\n</code></pre></div>",
        "id": 198387395,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590101248
    },
    {
        "content": "<p>another is how to parse this:</p>\n<div class=\"codehilite\"><pre><span></span><code>(module\n  (type (module))\n  (module (type 0))\n)\n</code></pre></div>",
        "id": 198387420,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590101273
    },
    {
        "content": "<p>which are sort of the same concern</p>",
        "id": 198387428,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590101277
    },
    {
        "content": "<p>basically everything in parsing only requires 1 lookahead right now, but those would otherwise require multiple tokens of lookahead</p>",
        "id": 198387498,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590101298
    },
    {
        "content": "<p>it's not necessarily ambiguous but it is pretty weird</p>",
        "id": 198387519,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590101313
    },
    {
        "content": "<p>Ohhhhh, I finally get your meaning; you're saying: when I see the tokens <code>(</code> <code>module</code> <code>(</code> <code>export</code>, I don't know if I'm parsing an export of the module definition, or declaring that this module definition is exported.  I was thinking of it as an already-parsed AST which is after this question has been sorted :)</p>",
        "id": 198464696,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590165845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> oh sorry, but yes</p>",
        "id": 198465153,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590166077
    },
    {
        "content": "<p>So I suppose in both cases, the (export \"x\") and (type 0) require a constant amount of lookahead to see what they are</p>",
        "id": 198465247,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590166110
    },
    {
        "content": "<p>that's why I was thinking of <code>(nested-module ...)</code> because that would put you in a parsing context where you clearly know what's what</p>",
        "id": 198465263,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590166116
    },
    {
        "content": "<p>that's true yeah</p>",
        "id": 198465268,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590166119
    },
    {
        "content": "<p>the constant is just bigger than 1 heh</p>",
        "id": 198465280,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590166124
    },
    {
        "content": "<p>are you using an LR(1) parser generator?</p>",
        "id": 198465314,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590166141
    },
    {
        "content": "<p>nah it's all hand-coded so it's easy enough to do</p>",
        "id": 198465329,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590166148
    },
    {
        "content": "<p>but it also just looks funky</p>",
        "id": 198465345,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590166156
    },
    {
        "content": "<p>from a readability point of view</p>",
        "id": 198465355,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590166161
    },
    {
        "content": "<p>not that inline exports/imports are used all that often</p>",
        "id": 198465364,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590166166
    },
    {
        "content": "<p>well it's a good question, i'll file an issue on the repo after we merge the linking PR (i'm thinking mid next week)</p>",
        "id": 198465404,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590166187
    },
    {
        "content": "<p>I'll stick to \"just do more lookahead\" for now</p>",
        "id": 198465470,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590166204
    },
    {
        "content": "<p><span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 198465496,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590166216
    },
    {
        "content": "<p>Hm ok so I'm getting really tripped up how to implement <code>alias</code> statements in text parsing</p>",
        "id": 198493950,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590180965
    },
    {
        "content": "<p>everything is so circular and I don't know how to untangle things</p>",
        "id": 198493955,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590180973
    },
    {
        "content": "<p>so right now \"elaboration\" is a pretty simple 3-phase process</p>",
        "id": 198493972,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590180987
    },
    {
        "content": "<p>er, 4 I guess</p>",
        "id": 198493977,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590180990
    },
    {
        "content": "<p>1) expand inline imports/exports<br>\n2) expand inline type annotations to actual type declarations<br>\n3) record what index each name is at<br>\n4) fill in all names with their indexes</p>",
        "id": 198494024,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181026
    },
    {
        "content": "<p>during step (4) we also have this extra \"validate the inline function type matches the referenced type\" if you do something like <code>(func (type 0) (param i32))</code></p>",
        "id": 198494053,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181046
    },
    {
        "content": "<p>but I don't know how to do this for modules</p>",
        "id": 198494062,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181053
    },
    {
        "content": "<p>so if you have a nested module like <code>(module (module))</code></p>",
        "id": 198494078,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181061
    },
    {
        "content": "<p>then that needs to be elaborated to </p>\n<div class=\"codehilite\"><pre><span></span><code>(module\n  (type (module))\n  (module (type 0))\n)\n</code></pre></div>",
        "id": 198494105,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181082
    },
    {
        "content": "<p>so when the module type isn't listed, we need to calculate it an inject it as a module type</p>",
        "id": 198494166,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181098
    },
    {
        "content": "<p>but I'm not sure how we can calculate it in the face of <code>(alias (parent ...))</code></p>",
        "id": 198494188,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181110
    },
    {
        "content": "<p>because that needs information from the parent, which if we're only in step (2) we don't even have symbolic names yet</p>",
        "id": 198494204,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181127
    },
    {
        "content": "<p>much less stable indexes because we're still injecting new type annotations depending on what we're seeing</p>",
        "id": 198494226,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181139
    },
    {
        "content": "<p>so like for example</p>\n<div class=\"codehilite\"><pre><span></span><code>(module\n  (module\n    (alias (parent (type 0)))\n    (func (type 0) (param i32))\n  )\n)\n</code></pre></div>",
        "id": 198494298,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181182
    },
    {
        "content": "<p>the definition of the parent module's type 0 is going to be the type of the inlined module</p>",
        "id": 198494324,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181198
    },
    {
        "content": "<p>but the inlined module references that</p>",
        "id": 198494373,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181204
    },
    {
        "content": "<p>Some of this is just complexity I think, but I'm just stuck at what to do</p>",
        "id": 198494489,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181281
    },
    {
        "content": "<p>I don't know if I should just throw everything out and start from scratch with a complicated resolver</p>",
        "id": 198494505,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181293
    },
    {
        "content": "<p>or try to fit things cleanly into what already exists</p>",
        "id": 198494515,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181300
    },
    {
        "content": "<p>I can't tell if all this elaboration/name resolution has to happen in cycles till it reaches some sort of fixed point or otherwise what the precise order of passes is to figure everything out correctly</p>",
        "id": 198494597,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181339
    },
    {
        "content": "<p>Another example would be</p>\n<div class=\"codehilite\"><pre><span></span><code>(module\n  (module\n    (alias (parent (type $foo)))\n    (func (type 0))\n  )\n  (type $foo (func))\n)\n</code></pre></div>\n\n\n<p>I don't know what order to do things. The index of <code>$foo</code> is 1, but we don't know that until the type of the nested module is elaborated. We can't do that though until we figure out what it's <code>parent</code> reference is pointing to</p>",
        "id": 198494911,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590181534
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> So for the text format parsing, my inclination would be to say that, when you see an explicit type declaration, you simply bake in that index, no questions asked; if the module fails to validate, it's the author's fault</p>",
        "id": 198496055,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590182243
    },
    {
        "content": "<p>oh sure yeah wat does extremely little validation</p>",
        "id": 198496094,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182273
    },
    {
        "content": "<p>this is more just about trying to do name resolution where we're figuring out what indexes are assigned to everything</p>",
        "id": 198496148,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182287
    },
    {
        "content": "<p>like is this supposed to work?</p>\n<div class=\"codehilite\"><pre><span></span><code>(module\n  (type $foo (instance\n    (export &quot;&quot; (func $bar))\n  ))\n  (module\n    (alias (parent (type $foo)))\n    (import &quot;&quot; (instance $i (type 0)))\n    (alias ($i (func $bar)))\n    (func\n      call 0)\n  )\n)\n</code></pre></div>",
        "id": 198496317,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182451
    },
    {
        "content": "<p>So one thing we can do for now (and perhaps forever) is to say that aliases can only refer to preceding definitions</p>",
        "id": 198496528,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590182636
    },
    {
        "content": "<p>but even in the above case</p>",
        "id": 198496598,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182667
    },
    {
        "content": "<p>we're doing name resolution across modules</p>",
        "id": 198496602,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182671
    },
    {
        "content": "<p>and everything is in preceding order and everything</p>",
        "id": 198496612,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182678
    },
    {
        "content": "<p><code>(alias ($i (func $bar)))</code> realizes that <code>$i</code> resolves to local instance 0, which is imported, which has a type defined locally, but that type was aliased from a parent module</p>",
        "id": 198496650,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182717
    },
    {
        "content": "<p>like these are kind of \"dumb concerns\" in that they're only really applicable to the implementation of a text parser and don't really have many implications on the binary format</p>",
        "id": 198496687,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182750
    },
    {
        "content": "<p>I'm tripping myself up so much because the text format is so simple today and I can't figure out how to make the addition of modules as simple as it is right now</p>",
        "id": 198496759,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182780
    },
    {
        "content": "<p>without having things like global name resolution and tombstones for \"this'll get resolved later\" and things like that</p>",
        "id": 198496776,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182796
    },
    {
        "content": "<p>Yeah, I think the text parser has to maintain a stack of identifier scopes (one per nested module) that it updates in a linear pass over the AST</p>",
        "id": 198496796,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590182812
    },
    {
        "content": "<p>I suppose what this means is that <em>some</em> identifiers (e.g., calls to $functions in function bodies) get resolved at the end (b/c they are allowed to be circular), while some get filled in as part of a linear pass</p>",
        "id": 198496862,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590182862
    },
    {
        "content": "<p>yeah that's also the weird part for me</p>",
        "id": 198496888,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182879
    },
    {
        "content": "<p>the text format is super loose today in that you just throw things in a soup and a valid module almost always pops out</p>",
        "id": 198496945,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182897
    },
    {
        "content": "<p>but this is starting to place lots of restrictions of \"no everything has to be very strictly ordered\"</p>",
        "id": 198496961,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590182908
    },
    {
        "content": "<p>well, i think every identifier that exists today would be in this \"fill in at the end when all identifiers are known\" category,</p>",
        "id": 198497003,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590182938
    },
    {
        "content": "<p>and we're just introducing a new \"kind\" of identifier that gets resolved in a new, earlier, linear pass</p>",
        "id": 198497067,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590183001
    },
    {
        "content": "<p>that makes sense, yeah, and I'm getting tripped up trying to not do that</p>",
        "id": 198497157,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590183034
    },
    {
        "content": "<p>it feels wrong to have \"oh these identifiers work only linearly\" and \"oh but those identifiers can work anywhere\"</p>",
        "id": 198497172,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590183049
    },
    {
        "content": "<p>and I can't figure out how to prove \"yes the linear stuff is required due to this design constraint\"</p>",
        "id": 198497190,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590183068
    },
    {
        "content": "<p>heh, i guess that's sortof the case with C++; in <code>struct C { typedef int X; X foo() { bar(); } X bar() { foo(); }</code>, the names bar() and foo() can be cyclic whereas the reference to X has to be in order</p>",
        "id": 198497255,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590183121
    },
    {
        "content": "<p>I'll just try to work something out</p>",
        "id": 198497413,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590183238
    },
    {
        "content": "<p>But yeah, I see what you mean, the current parse rules simply parse every field in isolation and then do name resolution as a wholly separate, order-independent pass</p>",
        "id": 198497489,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590183294
    },
    {
        "content": "<p>Trying to think a bit more about what the general rule is, I think it's this: you do most name resolution in a linear pass, and any time a name is un-resolved:</p>\n<ul>\n<li>if it's an identifier that is part of an alias or instance definition (the two new kinds), fail</li>\n<li>otherwise, put in a placeholder</li>\n</ul>\n<p>Then, in a second pass, go over the placeholders and check that they resolve to a name <em>and</em> that name is <em>not</em> an alias or instance definition</p>\n<p>Thus, only name cycles involving aliases or instance definitions would be disallowed; everything else should get resolved as it is today</p>",
        "id": 198498519,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590183987
    },
    {
        "content": "<p>I think that sounds reasonable, yeah, I got further today in implementing all this, I think this is the last step for the text format</p>",
        "id": 198504819,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590188731
    },
    {
        "content": "<p>I'll work on getting this implemented next week to see if it all works</p>",
        "id": 198504841,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590188751
    },
    {
        "content": "<p>I'm still trying to wrap my head around the set of changes here</p>",
        "id": 198822310,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590527530
    },
    {
        "content": "<p>I'm definitely getting from the point that <code>wat</code> was previously a pretty simple parser with a single pass to resolve names, but now it's becoming more of a compiler almost where it's got a type resolutoin pass and such</p>",
        "id": 198822377,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590527556
    },
    {
        "content": "<p>but to confirm, <span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> the encoding of this module:</p>\n<div class=\"codehilite\"><pre><span></span><code>(module $outer\n  (module $inner\n    (module $child (export &quot;a&quot;))\n  )\n)\n</code></pre></div>\n\n\n<p>would look like this?</p>\n<div class=\"codehilite\"><pre><span></span><code>(module $outer\n  (type $child_type (module))\n  (type $inner_type (module\n    (export &quot;a&quot; (module (type $child_type)))\n  ))\n\n  (module $inner (type $inner_type)\n    (alias $child_type_inner (parent (type $child_type)))\n    (module $child (type $child_type_inner))\n    (export &quot;a&quot; (module $child))\n  )\n)\n</code></pre></div>",
        "id": 198822480,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1590527586
    },
    {
        "content": "<p>Yeah, that looks right, and yes, I can see how this makes the text-to-binary a lot more complicated</p>",
        "id": 198823482,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1590528222
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> <code>(export $some_instance)</code> is only intended to be sugar for the text format, right? not reflected in the binary format?</p>",
        "id": 199410046,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591038566
    },
    {
        "content": "<p>Good question!  For now: yes.  At some point in the future, when one can import instances of imported instance types (O_O), they may need to become first-class things b/c it won't be possible to desugar them at text-to-binary time</p>",
        "id": 199412476,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591039789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> The'</p>",
        "id": 199434942,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1591053299
    },
    {
        "content": "<p>There's no way to use interface types with a global, right?</p>",
        "id": 199434959,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1591053315
    },
    {
        "content": "<p>And as a related question, in theory commands could have immutable global exports, which could be a way for commands to export metadata, however without the ability to export strings or other higher-level types, that may not be very valuable.</p>",
        "id": 199435090,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1591053466
    },
    {
        "content": "<p>Good question!  Coincidentally I was just thinking about this and how it might work for stuff like metadata.  It seems like one could have, as a component import/export an interface value (not const global, just a pure value) and this could be lowered into a core const global import, and this could allow one to import compound JSONesque values</p>",
        "id": 199435622,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591053970
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span></p>",
        "id": 199435681,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591054073
    },
    {
        "content": "<p>Ah, and by being a value export, rather than a global export, you'd read it with an adapter function, and not with global.get</p>",
        "id": 199435962,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1591054327
    },
    {
        "content": "<p>Yup!  And it lets you perform a one-time conversion (performing malloc etc)</p>",
        "id": 199436122,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591054459
    },
    {
        "content": "<p>Without thinking about global.set</p>",
        "id": 199436136,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591054477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> here's an interesting question, how should this be encoded?</p>\n<div class=\"codehilite\"><pre><span></span><code>(module\n  (import &quot;&quot; (module))\n  (type (module)))\n</code></pre></div>",
        "id": 200484411,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591827306
    },
    {
        "content": "<p>the <code>import</code> annotation has an \"inline\" type annotation</p>",
        "id": 200484440,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591827324
    },
    {
        "content": "<p>but this inline type annotation is listed later</p>",
        "id": 200484451,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591827329
    },
    {
        "content": "<p>with functions this works today because you just encode all types first</p>",
        "id": 200484472,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591827347
    },
    {
        "content": "<p>but with the first 5 sections in any order, it's unclear what the text format is supposed to do here in that regard</p>",
        "id": 200484537,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591827364
    },
    {
        "content": "<p>e.g. does this encode as:</p>\n<div class=\"codehilite\"><pre><span></span><code>(module\n  (type (module)) ;; injected\n  (import &quot;&quot; (module (type 0)))\n  (type (module)) ;; original type annotation\n)\n</code></pre></div>",
        "id": 200484582,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591827394
    },
    {
        "content": "<p>or like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>(module\n  (type (module)) ;; original annotation reordered first\n  (import &quot;&quot; (module (type 0)))\n</code></pre></div>",
        "id": 200484614,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591827418
    },
    {
        "content": "<p>I suppose I'm answering my question as I'm writing this down, it basically has to be the former</p>",
        "id": 200484635,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591827430
    },
    {
        "content": "<p>this is just weird because now this doesn't behave as functions do</p>",
        "id": 200484653,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591827438
    },
    {
        "content": "<p>Yeah, good question.  So in the analogous function situation, when the inline type def goes before the explicit type def... do you get two type defs or 1?</p>",
        "id": 200489149,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591830242
    },
    {
        "content": "<p>/me goes to look at spec</p>",
        "id": 200489192,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591830251
    },
    {
        "content": "<p>By my reading, an inline func type followed by explicit func type def will produce two type defs: only inline funcs \"reach back\"; type defs don't</p>",
        "id": 200489816,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591830771
    },
    {
        "content": "<p>Thus, I think the your former module case would be symmetric to funcs</p>",
        "id": 200489828,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591830785
    },
    {
        "content": "<p>... and yet, wabt's wat2wasm seems to merge them</p>",
        "id": 200489969,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591830892
    },
    {
        "content": "<p>I think technically that's a bug in wabt</p>",
        "id": 200489998,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591830913
    },
    {
        "content": "<p>ah yeah I've mostly gone by wabt's behavior which may be a bug</p>",
        "id": 200490000,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591830918
    },
    {
        "content": "<p>well, practically speaking, i'd do whatever was easiest for now, but if it's the former, i wouldn't feel bad about it</p>",
        "id": 200490041,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1591830959
    },
    {
        "content": "<p>order of items previously in the text format have largely been irrelevant, but with the 5 sections at the front that can be all interleaved I think it's a lot more imporatnt now</p>",
        "id": 200490213,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591831068
    },
    {
        "content": "<p>so I don't think there's actually any opiton other than the first, injecting a duplicate annotation</p>",
        "id": 200490224,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591831078
    },
    {
        "content": "<p>it's a relatively niche concern anyway though, it generally needs to just work</p>",
        "id": 200490282,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591831105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253991\">@Yury Delendik</span> did you want to join a video chat about <a href=\"https://github.com/bytecodealliance/wasm-tools/pull/26\">https://github.com/bytecodealliance/wasm-tools/pull/26</a> ?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-tools/pull/26\" style=\"background-image: url(https://avatars0.githubusercontent.com/u/54038801?s=400&amp;v=4)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-tools/pull/26\" title=\"Initial implementation of module linking by alexcrichton · Pull Request #26 · bytecodealliance/wasm-tools\">Initial implementation of module linking by alexcrichton · Pull Request #26 · bytecodealliance/wasm-tools</a></div><div class=\"message_embed_description\">This commit is the initial implementation of the module linking proposal\nin the three tooling crates of this repository. Unfortunately this is\njust one massive commit which isn&#39;t really able to...</div></div></div>",
        "id": 200715145,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591990549
    },
    {
        "content": "<p>sure</p>",
        "id": 200715255,
        "sender_full_name": "Yury Delendik",
        "timestamp": 1591990597
    },
    {
        "content": "<p>k cool, <span class=\"user-mention\" data-user-id=\"253990\">@fitzgen (he/him)</span> would you/yury be free this afternon?</p>",
        "id": 200715629,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591990802
    },
    {
        "content": "<p>/me is</p>",
        "id": 200715688,
        "sender_full_name": "Yury Delendik",
        "timestamp": 1591990831
    },
    {
        "content": "<p>Yeah, free in roughly an hour and then for the rest of the day</p>",
        "id": 200715706,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1591990842
    },
    {
        "content": "<p>k cool I'll send an invite</p>",
        "id": 200715816,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1591990910
    }
]