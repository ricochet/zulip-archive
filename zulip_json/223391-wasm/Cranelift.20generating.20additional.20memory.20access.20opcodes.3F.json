[
    {
        "content": "<p>Hello, I'm a (W)ASM novice &amp; attempting to figure out why a precompiled WASM binary seems to have additional memory access as compared to the LLVM version. <br>\nI am not the author of the program, however I communicate with them. </p>\n<p>These are two perf reports of the same function.<br>\n<a href=\"https://dzaima.github.io/paste/#01VVLbtswEN3rFFzUQAIYgkTZ1gdFV8kyQG8QUCQFK5CsVGQM5QLZN71hT1LSFCX@4P7QRWdjynwzmjfvkbo/0xOvAH7FHWVR9JmOWPwB5oiAHVef71qGGKN93b2CoQGMYt4OJxBzOvHqamayxC6B@zoBHxEhjxh@stPUnze3lcxO4izVG88v7KhWmxFNYrOMy1xv9sMZ1UyuPiRT2hhBt5sRT05nFtxEE4EuIwBhnEIN7iiaVzeylECwdgtvxS9pnbo@lEwKemkhj7ODhuL@GWg6pV/r@9s38FTT@SnDnixuvsMxlJ8WcV4YI/ii8wWfzdT3iT@lBSJ4SEgqILs42xlqMaIgssCCMYUzysjdrZIvO8TFqu2wkvHEGikPeSrDlatk3jRpYoR4VeFzAiZtZSUz2HGcV6JiloQg6@znl/qgy/xPev7F4e/0C@QHxHH1w2fOGYGs1eIEmJw5a6GUUG4u8pnxgoe@vYg8y@e9yeZK9k6vl21N1t@2NKFSE@pZQNgMrGc/dKItSdJ0Vj80VKQbxdDoJG8qpxN5fKk3sEGbQ3RShCb6J1YuDtXv3ggYh8ZoX2rOUfBaRad1qtJC14weZGsLH27pZ5fM/2hSOax/aNKvQufVl0YnGNomFVV2dQmpqEI9t7wDjLpOPfHj@LBWwVXoIvQ@ZiaCqM/eFa971ngHTwtd9VF/ROMYrSMOcdkn@1/i8gM#y0nMS9dQL0gtSlPXMTQw0LQGAA\">LLVM</a><br>\n<a href=\"https://dzaima.github.io/paste/#03VhZjpxIEP3vU/DhltpSC0UkUCSl0Xx5/ucGLZYsGasWXEm38QXmAOMb@iROsoBOkiChW@U1v2p5FcuLyHhB/fMkjvXWyz/neyFvbv4V51x94HXnxhsf9/t3pUylFIds/9k77Twp8ro8HT2/Fk29df8URocz76@HT6k8POwej9rIAyZ/WyYmgLu3LQJ9DAdM9SjfX17dnrNK@UTw42D4@nB68vqvZXXfYpQF5kcbAnJ3ey7KtwqEoECRHwU0CGEAjU5@qMbONAT9KOk@/vrfF@9DJrp3GBF8PxbM4hD8DdforZVPUSoXaaMhjE45Ke5vRVFqSMAJCDQY8rvWTJuSVEhEH0ISCXct4l47xoGBwGcx6RtBQxUkNCHy/b579UY57yHgJ8y0kmayh@yMIxQ@b7RXxAGfFsXgNW@eTY7r99EMrDkccJ6V2zNvicsv3Iaxmw7lUtOh4ZHPOem1DUx57ToCSK86@EQzBnyesUSHFcNKwriCczMLky8@2Ntw2h5ljvlxTLZ9b844l6bv3/G472rd/iv9zV4z3ld74/PYdJj2tywAMG8Zj7eUQ3M2tZ2NttNJmSZhpcdnVhEpxMhrvNvholczVcqmTvXYp5oVxEC5Are2w4FbBoHpMCu2Sw5te2OPeqI522cXrEnR4pW7ivk8pmaryUnEUjVfx21PrdKxjZnpLrDHf9rMhTWGyHIx/UlX/e/l6X5PqjADl7mslT1Z2ZDqVHkjlR6fs6jJxUFxsCWYHp05Ej6aTdWNe7vC1aXGei7ToJHrMBBgFXmVazYR@fx0KGXRuUYaJEWddoaKcu/NN@hFFcQ0lFrIjtf2WwIyHh8Ypgt3i4@XOJhr4qHRMTEHhHLQl7OSC8TnT3UtCybLniLn6DBXiUl@JzIYRymQsjKk1Ork8tY2gCcNnE@7SG8Os13UbQ4LXcRmQx/GNfLgBaFzPXGa09m4JezV/WxFkrwkkkRHojpClqz1Mn@nqUCACKQabKeTalpjODMvhYJ/jzHctm8cifaGNi8YxTyA1Rxm6aw2kw1o6p/ed6aPO@YaqZUbwZ0iXtpdrFgCEFxbAAp6Ul29KJso@Z5FEel2xSIxzeN09tYz38ZPkm6tAfYD3o@TebVGXk3mwS3zSIN@hMzDLyLzrH0SvK7Ms8R8xlIOpjI/Q/xY5uEaMj8OxlEKcMk820TrFUqB18g8dzURXy/y4Hwm4/CCwDm8UuRhWeTpQsxFksCMyMOaQNAl8iyN3CLPMvNKKPjvKfIqDZfI86VnXGILsCWe3FRfJ/F545J4JuI/QeJVGleSeBfzqyRebXE/Q@ID/WdnAPp6q36SlBiHfhwt5BVaf@dK89mdSCyg/8Y2E0M/2DgSC/0EZxP7Bg#y0nMS9dQL0gtSlPXMTQw0LQGAA\">WASM</a></p>\n<p>the WASM version seems to have additional memory accesses that aren't present in the LLVM version, and more overall time spent shuffling memory.</p>\n<p>this is in a virtual machine interpreter loop, so I might have to do some digging to find an isolated, reproducible case.</p>",
        "id": 278430030,
        "sender_full_name": "Rowan Cannaday",
        "timestamp": 1649537615
    },
    {
        "content": "<p>Was the WASM binary compiled with SIMD enabled? x86_64 mandates at least SSE2 (128bit simd vectors) so you get basic SIMD even without doing anything special. WASM only introduced SIMD some time after the first release so clang and rustc by default compile without SIMD usage enabled for better compatibility. This does somewhat reduce performance and in general doubles the amount of memory accesses necessary for copying values larger than 64bit.</p>",
        "id": 278431142,
        "sender_full_name": "bjorn3",
        "timestamp": 1649538941
    },
    {
        "content": "<p>i compiled a 2nd time with <a href=\"https://dzaima.github.io/paste/#03VhLjts4EN33KbRIAx2gQbAoyaaMwayS/dygoQ@NKPBHMdUd5QI5wMwN5yShKEumqCIlN9xJZrhq26/r86pYr6SPL@JQb4L8W74T8u7uL3HK1RfB@dwF4@P//KGUqZRin@2@BcdtIEVel8dDQGrR1Bv/v9LR4Sz44@lrKvdP2@eDNvIEyZ@WiQng4X2LoATogKme5afur/tTVimfEJIoGn7eH1@C/mdZPbYYZSEibIVAHu5PRflegYAqUEhiwEFAB9Do5Ptq7ExDgETs/PW/3/8JPmfi/AlihO/nglkcMhLHGr2x8ilK5SJtbAsmJCke70VRuiG0gYg/tGbalGSpyVlFKJI@tIhH7Rh6BiAidIX6Bqqhmkl2sSg/7c5/vVPOe4gdXprJHrI1jlD4vOlMXrymRTF4zZveJJAVNU1@MQNr9nvwEcdb4vLGR9xAh3Kp6dDwmABHvbaBKa9WR4y96uCTrsUTN2OJfQn8hHFVJUrCEOWLn@0B4QluDzGnepLHaNv35ozTNX3/ia@Rpp/157xmvK/2@hKRdpj2tyyk1HTI1xvMoTmb2s72Nocu0ySs9HBhFQBDjLyut1uY9WqmitnUqR76VLPibbi1HQ7cMhqaDrNiM@dwetlNj3qiedtnGy5J0eKV@4p5GVPOavL5KYVU83Xc9tSqK7syM92G9vhPG1dYY4gsZ9OfdNXfQZ7udqgKM@ozl7WyJysbUh2rYKTS43MSNbo4KA42CNOj4yLhi9lU2LhXFa66Guu57NSEi@soFNQq8iLXbCLy@XFfyuLsGnCQFHV6NlSUu8DdoJ0qIDJfC3nmtf0VgYzHB0TpzN3i4yWOupp4aHRIzAGhHPTlrOQM8flLXcuCybKnyDs6HKtEl98RDcZTCsCsDCmt@JKtbQBPGjifdhG6aNibw0wXMWfow7gGHl4ROtcTpzmejFvCXt3PViTJNZEkOhLVEbJkrRf3ncYCoUgg1WA7nVTTGsOZeSkU/C3GcNu@61i0N7S5YhTzkC7mMEud2ow2oKl/et@ZPu6Ya6RWbqD@FKFrd7FgCQDq2wJA4JPq5kVZxclbFkWkmwWLxDSP4ylYznwb/8xToF4D7Ae8nyfzao28mcxTv8wDDvoZMk9/E5ln0frWMs8S8xlLOZjKvIP4sczTW8j8OBhPKahP5tkqXq5QCrxE5rmvifhykafeZzJOrwic01eKPJ0XebwQrkgS6hB5uiQQ8Ik8S2O/yLPMvBIK/t8UeZWGT@T53DMusgXYEu97JXalxOeNT@KZWP8fJF6lcSOJ9zG/SOLVFvcrJH5NGOi3cJuunyQmxkAYm8krJGz0wlOaz@5IYvbrXySxkITgSQxInDgT@wE#y0nMS9dQL0gtSlPXMTQw0LQGAA\">SIMD enabled</a>.</p>",
        "id": 278431422,
        "sender_full_name": "Rowan Cannaday",
        "timestamp": 1649539246
    },
    {
        "content": "<p>Also try with <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3989\">https://github.com/bytecodealliance/wasmtime/pull/3989</a> This PR switches to a new register allocator which should produce faster code than the current register allocator.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/3989\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/cca1bc7bab3c42770bd44054d8a228bfebfe435c\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303439373038363536643933363031323030396264636638366633396230656133643234353833633630303435366136613334313636306231356539356661312f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f33393839)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/3989\" title=\"Switch Cranelift over to regalloc2. by cfallin 路 Pull Request #3989 路 bytecodealliance/wasmtime\">Switch Cranelift over to regalloc2. by cfallin 路 Pull Request #3989 路 bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This is a draft PR for now, meant to serve as a discussion-starter. I'll work on splitting this into logically separate commits next week, but wanted to get the initial thing up first.\nAll tests pa...</div></div></div>",
        "id": 278431452,
        "sender_full_name": "bjorn3",
        "timestamp": 1649539289
    },
    {
        "content": "<p>it doesnt seem to make a difference, however this build doesnt include a lot of simd code, so i might try to enable that and recompile as wasm w/ simd enabled</p>",
        "id": 278431453,
        "sender_full_name": "Rowan Cannaday",
        "timestamp": 1649539289
    },
    {
        "content": "<p>oh thx! ill try regalloc2</p>",
        "id": 278431469,
        "sender_full_name": "Rowan Cannaday",
        "timestamp": 1649539309
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"493273\">@Rowan Cannaday</span> when you say \"LLVM version\", do you mean a build to a native binary? And when you say \"additional memory access\", it sounds like you mean the static count (number of loads/stores in the disassembly), rather than some runtime measurement?</p>\n<p>The reason I ask for clarification on the first is that comparing Wasm vs. native is quite different than comparing compiler backends. In other words this isn't so much (or <em>just</em>) a Cranelift vs. LLVM question as it is a \"running in a sandbox\" vs. \"running in a native runtimeless environment\" question, if I am reading this correctly.</p>\n<p>The reason I ask for clarification on the second is that running Wasm code under Wasmtime involves code paths in the runtime as well, which will naturally access memory; but if we're just looking at static disassemblies then we don't have to worry about that.</p>\n<p>The Wasm-vs-native comparison will at least imply additional memory accesses for indirect (function pointer or virtual method) calls, as these go through tables; and some memory accesses to get the Wasm memory info from the VM context; and memory accesses to the VM context for stack-limit checking, if configured; and a little more metadata handling on calls to imported functions; and probably some other stuff I'm forgetting.</p>\n<p>Then when we get to the actual compiler comparison, even with identical IR (ie in a hypothetical world where we compare a native compiler using Cranelift vs clang+LLVM, or where we compare Wasmtime+Cranelift to a Wasm frontend + LLVM), I wouldn't be surprised if we do a bit worse, because LLVM can do redundant load elimination, store-to-load forwarding, dead store elimination, and in general reason about memory operations more fully than we can. Some of this is on our TODO list for optimizations to build, but some of it is also not possible for Wasm code due to strict trapping semantics.</p>\n<p>Anyway, depending on clarifications above I'd be happy to discuss further and see what we can do!</p>",
        "id": 278438525,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1649549711
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"254389\">@Chris Fallin</span> , this is helpful. As I said, I'm a ASM novice, so I'm probably not asking the right questions. I'm also not the person who wrote the <a href=\"https://github.com/dzaima/CBQN/\">application</a>. I'm mostly trying to figure out where the bottlenecks are specific to my use-case such that over time they can be contextualized.</p>\n<p>I'm pasting dzaima's comment from another channel (I'm instigating as the go-between: WASM optimization is low on his priority list right now).</p>\n<blockquote>\n<p>cranelift isn't meant to be only JITted, its calling convention is such that it's easy to use for non-JITted code, i.e. everything is passed on the stack. Then there's the fact that every memory read &amp; write must have bounds checks added, which requires knowing the bounds in the first place, which you'll have to get from reading some global variable in RAM at the start of the function. Usually that's fine as most functions are large, but scalar code in CBQN can call a ton of tiny functions, where that overhead is pretty big</p>\n</blockquote>\n<p>so it sounds like this is currently just the reality of compiling and running to wasm with the biggest contributors being:</p>\n<ul>\n<li>WASM calling convention</li>\n<li>bounds checking</li>\n<li>optimizing for many tiny functions</li>\n</ul>\n<p>CBQN doesnt have SIMD operations for WASM (only x86), so this is still a potential improvement too.</p>\n<p>the following compile time options are being used:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">wasm32</span><span class=\"o\">-</span><span class=\"n\">wasi</span><span class=\"s\">\" LDFLAGS=\"</span><span class=\"o\">-</span><span class=\"n\">lwasi</span><span class=\"o\">-</span><span class=\"n\">emulated</span><span class=\"o\">-</span><span class=\"n\">mman</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">wasm32</span><span class=\"o\">-</span><span class=\"n\">wasi</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">Wl</span><span class=\"p\">,</span><span class=\"o\">-</span><span class=\"n\">z</span><span class=\"p\">,</span><span class=\"n\">stack</span><span class=\"o\">-</span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">8388608</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">Wl</span><span class=\"p\">,</span><span class=\"o\">--</span><span class=\"n\">initial</span><span class=\"o\">-</span><span class=\"n\">memory</span><span class=\"o\">=</span><span class=\"mi\">67108864</span><span class=\"s\">\" LD_LIBS= PIE= c</span>\n</code></pre></div>\n<p>Thanks again!</p>\n<ul>\n<li>Rowan</li>\n</ul>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/dzaima/CBQN/\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/6675e7db16d153dd48f10e35d663b87d44dd4406\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353231623162383263653537383332333262323666373034396137303831376632663963316132343337656433613161616634626463383538363166656138372f647a61696d612f4342514e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/dzaima/CBQN/\" title=\"GitHub - dzaima/CBQN: a BQN implementation in C\">GitHub - dzaima/CBQN: a BQN implementation in C</a></div><div class=\"message_embed_description\">a BQN implementation in C. Contribute to dzaima/CBQN development by creating an account on GitHub.</div></div></div>",
        "id": 278471329,
        "sender_full_name": "Rowan Cannaday",
        "timestamp": 1649601270
    },
    {
        "content": "<blockquote>\n<p>cranelift isn't meant to be only JITted, its calling convention is such that it's easy to use for non-JITted code, i.e. everything is passed on the stack. </p>\n</blockquote>\n<p>Hmm, that's interesting -- Wasm-to-Wasm calls use the standard ABI on the platform (on Linux/x86-64, this is the System V ABI, which puts the first 6 int args / first 8? float args in registers). It's not clear to me what JIT vs non-JIT modes of use would have to do with this -- in either case code is ultimately invoked by a function call, and it either has the right ABI or you use a trampoline.</p>\n<p>Anyway, that's a small point, and the bigger point of Wasm imposing some overheads stands. It's worth noting that this overhead isn't for nothing: it's the cost of software-enforced sandboxing, which guarantees that Wasm code cannot touch memory or corrupt state outside its heap. Whether that is more important than the last bit of performance is up to the particular application, though we'll keep looking at ways to shrink the gap!</p>",
        "id": 278485561,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1649619102
    }
]