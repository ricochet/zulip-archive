[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-901629357\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>cc folks who participated in #13 and/or may be interested due to involvement in Cranelift backends: @fitzgen @sunfishcode @tschneidereit @abrown @jlb6740 @akirilov-arm @afonso360 @bjorn3</p>\n</blockquote>",
        "id": 249944522,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1629352169
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-901915930\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>One question I have before reading this RFC, would it be possible to have backend agnostic rules for things like 128bit ints or 64bit ints on 32bit systems? Kind of like the old legalization system, except without having to edit the clif ir in-place. As different architectures work differently, it may make sense to have partially or fully different rule sets for architectures with and without flags. In addition it should be possible to override rules for specific backends if they can do it more efficiently.</p>\n</blockquote>",
        "id": 249985864,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1629379677
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-902199551\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<blockquote>\n<p>Sorry if I've missed it, but my main confusion is over how extractor functions are defined, is the nitty gritty matching done in Rust and will just reuse the existing code?</p>\n</blockquote>\n<p>Extractors are defined in Rust, yeah, so it's sort of an FFI to \"runtime library code\" (from the point of view of the DSL). But they should be low-level: I expect that we'll have extractors for the <code>LowerCtx</code> API, e.g. fetching instructions that feed into operands, fetching immediates, and that sort of thing, plus machine-specific things like the various immediate formats (imm12, immlogic), plus <em>maybe</em> other escape hatches to general logic where we really need it.</p>\n<blockquote>\n<p>Also, would we be able to express instructions that have multiple outputs, such as pre/post indexed memory operations?</p>\n</blockquote>\n<p>This is an interesting one! In the most general form it needs multi-rooted DAG matching (i.e. we need to find the load/store and the add-to-pointer separately), which needs adjustments to our lowering loop as well. I don't see why a term-rewriting system in general couldn't express that, but it needs further thought.</p>\n</blockquote>",
        "id": 250040697,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1629402970
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-902200357\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<blockquote>\n<p>One question I have before reading this RFC, would it be possible to have backend agnostic rules for things like 128bit ints or 64bit ints on 32bit systems? Kind of like the old legalization system, except without having to edit the clif ir in-place. As different architectures work differently, it may make sense to have partially or fully different rule sets for architectures with and without flags. In addition it should be possible to override rules for specific backends if they can do it more efficiently.</p>\n</blockquote>\n<p>Indeed! The hope is that we can get back to that universe where we have fallback rules. In particular this should make e.g. fuller <code>i128</code> support across all platforms, and also the eventual buildout of our 32-bit platform support (if someone is sufficiently motivated to drive it), much easier.</p>\n</blockquote>",
        "id": 250040872,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1629403045
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-902868166\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'm slightly concerned about compile times. Working on LLVM and editing a .td file in one of the targets is not a great experience. It usually involves at least a 1 min build for my laptop, which is really disruptive. And while I now have a much better experience with a different machine, I would hate for us to find ourselves in the same situation.</p>\n<p>I don't know if this is going to be an issue, but we may want to think about ways to mitigate it if it does.</p>\n</blockquote>\n<p>I agree this could be a problem -- we'll have to see what it looks like when we have a prototype ready (it's coming soon-ish!).</p>\n<p>There are really three aspects to this, and we could make a difference to one of them with a certain change:</p>\n<ul>\n<li>Compile time of the DSL metacompiler. This depends in part on what we pull in (e.g., Peepmatic uses Z3 for typechecking, which takes a long time to build; my current prototype does not; there are other dimensions in which we could depend on an external crate or do something simpler internally) and on the complexity of the metacompilation in general.</li>\n<li>Compile time of the DSL, to generate Rust code (i.e., the tool invocation itself). We can be careful not to have anything too fancy in the compilation (e.g. inefficient algorithms when combining rules or building automata) -- the work on Peepmatic should at least give us a really good start here.</li>\n<li>Compile time of the code generated by the DSL compiler. This is impacted by our DSL compilation strategy: if we generate a really big Rust function with all the matching cases inlined and significant duplication, etc., it could be really bad; conversely if we generate carefully factored Rust code it may not be bad at all. This cost is paid whenever compiling Cranelift, even if not modifying the DSL.</li>\n</ul>\n<p>At least the first two (building the metacompiler, and invoking the metacompiler to generate Rust code from the DSL) <em>could</em> be removed from the Cranelift build time when the DSL code is unchanged by checking the generated Rust code into source control. I'll note that this is not the idiomatic Rust approach at all (that would be to run this from <code>build.rs</code> and put the output in <code>target/</code>); but it's an option, and does have some other attractive properties, e.g. making the generated code much easier to find for anyone who needs to follow or debug it. On the other hand, it adds potential for surprising errors when it gets out-of-sync.</p>\n<p>The edit-run debug loop depends on the last two only (presumably the DSL metacompiler will be built once then won't be changed if one is hacking on a backend); we get all three only when hacking on the metacompiler itself.</p>\n<p>Anyway, whether or not to check in the generated artifacts is a question we can discuss here as well -- thoughts?</p>\n</blockquote>",
        "id": 250152979,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1629483002
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-902868166\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'm slightly concerned about compile times. Working on LLVM and editing a .td file in one of the targets is not a great experience. It usually involves at least a 1 min build for my laptop, which is really disruptive. And while I now have a much better experience with a different machine, I would hate for us to find ourselves in the same situation.</p>\n<p>I don't know if this is going to be an issue, but we may want to think about ways to mitigate it if it does.</p>\n</blockquote>\n<p>I agree this could be a problem -- we'll have to see what it looks like when we have a prototype ready (it's coming soon-ish!).</p>\n<p>There are really three aspects to this, and we could make a difference to the first two with a certain change:</p>\n<ul>\n<li>Compile time of the DSL metacompiler. This depends in part on what we pull in (e.g., Peepmatic uses Z3 for typechecking, which takes a long time to build; my current prototype does not; there are other dimensions in which we could depend on an external crate or do something simpler internally) and on the complexity of the metacompilation in general.</li>\n<li>Compile time of the DSL, to generate Rust code (i.e., the tool invocation itself). We can be careful not to have anything too fancy in the compilation (e.g. inefficient algorithms when combining rules or building automata) -- the work on Peepmatic should at least give us a really good start here.</li>\n<li>Compile time of the code generated by the DSL compiler. This is impacted by our DSL compilation strategy: if we generate a really big Rust function with all the matching cases inlined and significant duplication, etc., it could be really bad; conversely if we generate carefully factored Rust code it may not be bad at all. This cost is paid whenever compiling Cranelift, even if not modifying the DSL.</li>\n</ul>\n<p>At least the first two (building the metacompiler, and invoking the metacompiler to generate Rust code from the DSL) <em>could</em> be removed from the Cranelift build time when the DSL code is unchanged by checking the generated Rust code into source control. I'll note that this is not the idiomatic Rust approach at all (that would be to run this from <code>build.rs</code> and put the output in <code>target/</code>); but it's an option, and does have some other attractive properties, e.g. making the generated code much easier to find for anyone who needs to follow or debug it. On the other hand, it adds potential for surprising errors when it gets out-of-sync.</p>\n<p>The edit-run debug loop depends on the last two only (presumably the DSL metacompiler will be built once then won't be changed if one is hacking on a backend); we get all three only when hacking on the metacompiler itself.</p>\n<p>Anyway, whether or not to check in the generated artifacts is a question we can discuss here as well -- thoughts?</p>\n</blockquote>",
        "id": 250153075,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1629483031
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-916561403\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Greetings all! I've been churning on a little prototype of the DSL described in this RFC -- or at least something very close to it, with tweaks as needed as I discovered interesting issues in implementation -- in order to get a feel for its semantics.</p>\n<p>For your consideration, a small sketch of an instruction selector in <a href=\"https://github.com/cfallin/wasmtime/commit/e60b4cf877a11c3b7c1615d1c9a92cf4abbb3406\">this commit</a>. It doesn't actually do anything yet; it's not wired up to the rest of Cranelift; but it <em>does</em> successfully pass through <a href=\"https://github.com/cfallin/isle\">this prototype ISLE compiler</a> and generate some Rust code.</p>\n<p>The little sketch in the commit above has some \"prelude\" that gives definitions to glue the DSL onto Cranelift, but the interesting bit is in <code>x64/lower.isle</code> -- some sample rules:</p>\n<div class=\"codehilite\" data-code-language=\"plain\"><pre><span></span><code>(rule\n (Lower (Iadd a (InputConst k)))\n (X86Add (InputToReg a)\n         (RegMemImm.Imm k)))\n(rule\n (Lower (Iadd (InputConst k) b))\n (X86Add (InputToReg b)\n         (RegMemImm.Imm k)))\n(rule\n (Lower (Iadd a b))\n (X86Add (InputToReg a)\n         (RegMemImm.Reg (InputToReg b))))\n\n(rule\n (Lower (Iadd a (InputSourceInst (Load addr off))))\n (X86Add\n  (InputToReg a)\n  (RegMemImm.Mem (Mem.BaseImm (InputToReg addr) off))))\n(rule\n (Lower (Iadd (InputSourceInst (Load addr off)) a))\n (X86Add\n  (InputToReg a)\n  (RegMemImm.Mem (Mem.BaseImm (InputToReg addr) off))))\n</code></pre></div>\n<p>This all can be bikeshedded to fine-tune the actual types and definitions as much as we want; the point is that we have a term-rewriting system, and descriptive terms in the \"extractors\" (LHS terms) and \"constructors\" (RHS terms).</p>\n<p>To head off any quick reactions to the verbose terms like <code>InputSourceInst</code> and questions such as \"why not just <code>(Iadd (Load ...) ...)</code>? I'd point back to the section of the RFC that motivates the \"programmable extractors\" with examples where we might want more than one such \"virtual term\" to be possible in a given context.</p>\n<p>To the best of my thinking right now, all of these rules are compatible with our main goals -- both quick (single-pass) lowering as compiled by the prototype compiler above, and a value-equivalence-based view of the lowering to aid verification and other formal efforts. (To see how, think of e.g. <code>InputSourceInst</code> as just the identity function -- it's a type-adapter that makes the lowering work but doesn't change the \"value\".)</p>\n<p>Let me know what you think! I am going to context-switch away from this for a little bit but (i) I will plan to braindump a good amount about the internals / implementation details / what I've learned while prototyping the compiler-compiler, and (ii) I do intend the above prototype to be a \"real\" starting point (modulo some cleanups) that we can develop into the actual implementation, if this RFC is accepted.</p>\n</blockquote>",
        "id": 252720023,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1631237438
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-918614370\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<blockquote>\n<p><code>\n(rule\n (Lower (Iadd a (InputSourceInst (Load addr off))))\n (X86Add\n  (InputToReg a)\n  (RegMemImm.Mem (Mem.BaseImm (InputToReg addr) off))))\n(rule\n (Lower (Iadd (InputSourceInst (Load addr off)) a))\n (X86Add\n  (InputToReg a)\n  (RegMemImm.Mem (Mem.BaseImm (InputToReg addr) off))))\n</code></p>\n</blockquote>\n<p>Is the idea that the <code>InputSourceInst</code> extractor will fail if the load isn't the same color as this operation and so we don't need to expose the coloring to the DSL, or is the lack of coloring here an oversight/simplification?</p>\n<p>Either way, I think that either building the coloring logic into the <code>InputSourceInst</code> extractor or exposing a new extractor specifically for checking color could work here.</p>\n</blockquote>",
        "id": 253168213,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1631570819
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-918623779\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is the idea that the InputSourceInst extractor will fail if the load isn't the same color as this operation and so we don't need to expose the coloring to the DSL</p>\n</blockquote>\n<p>Yes, exactly, it's a wrapper (or will be once we write the trait impl) around the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/4d4779b56311e7405c113d94241a3991857ef703/cranelift/codegen/src/machinst/lower.rs#L110-L126\"><code>LowerCtx method</code></a> to get the producer for an input, which implements the logic (involving matching color and/or purity) that allows an instruction to be merged in. So it will always fail when we aren't able to merge that far up the tree; all we need to reason about in the DSL is the shape of the tree that we want to match.</p>\n</blockquote>",
        "id": 253169478,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1631571532
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-918623779\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is the idea that the InputSourceInst extractor will fail if the load isn't the same color as this operation and so we don't need to expose the coloring to the DSL</p>\n</blockquote>\n<p>Yes, exactly, it's a wrapper (or will be once we write the trait impl) around the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/4d4779b56311e7405c113d94241a3991857ef703/cranelift/codegen/src/machinst/lower.rs#L110-L126\"><code>LowerCtx::get_input_as_source_or_const method</code></a> to get the producer for an input, which implements the logic (involving matching color and/or purity) that allows an instruction to be merged in. So it will always fail when we aren't able to merge that far up the tree; all we need to reason about in the DSL is the shape of the tree that we want to match.</p>\n</blockquote>",
        "id": 253169510,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1631571559
    },
    {
        "content": "<p>bnjbvr <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-921589163\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>While I think a better way to handle instruction selection and generation is necessary, I have a few concerns about this proposal, especially around this not reaching the ideal goal of simplicity we're looking for, and I am unsure about the use of a custom DSL for this task.</p>\n<p>Moving the <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#discussion_r699510208\">debate out of the comment</a>, I think this doesn't get us to a better place in terms of simplicity. Simplicity/easiness-to-use is largely subjective anyways, and the creator bias/hindsight bias make it so that a system one creates likely appears as being _simple_ to their own eyes. However, here even after re-reading the proposals a few times, I'm still hesitant about a few concepts that seem to be key to knowing how to do things (extractor/entrypoints/...). Introducing concepts is inevitable of course, but if these are hard to grasp for a majority of current and future contributors, the system wouldn't be very welcoming for users, becoming a large barrier to entry. I grasp from other people asking for detailed examples and supplementary blog posts explaining this new ISLE framework that I might not be the only one having uncertainties here; don't want to read too much into this, because I think I have been the only one expressing explicit concerns of this kind so far. In terms of complexity, I see it like this: adding a new single instruction? Probably fine, I can just copy-paste some other ISLE code, stealing bits here and there. Add a way to find a new kind of patterns? Unclear if I could do it. So adding a whole new target ISA? Sounds scary. All these things feel straightforward to me in the existing code base, but I am myself subject to the creator bias, of course :-) and navigating the code base is pretty easy thanks to the great Rust developer tools.</p>\n<p>And that relates to the second point: using a custom DSL for this kind of work would be a clear step backwards, in my opinion. We're talking about a small programming language here, which implementation will be tweaked, which \"programs\" (ISLE definitions) will need to be debugged, optimized, etc. Moving the old meta framework from Python to Rust was a clear win, because we got static typing which removed a whole range of error-proneness, and a better developer environment in general: being able to share code between codegen and meta, using Rust packages in the meta crate if needs be, using all the developer tools included in IDE (rust-analyzer <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>️). So getting back to a custom DSL, we'd lose debuggers, IDE functionalities, namely jump-to-definition i.e. the ability to look how things are implemented (\"what's an extractor? oh I could just jump to its definition, owait no, it's done in a different language at a different level, might as well just grep around in the code base, hoping that i'll find where/how it's done\"). This is not intractable of course, and all these tools _could_ be reimplemented but that might be a waste of resources to do so. Any of Rust/Python/TypeScript would be better fits at this point, since they now all have good development ecosystems (with a clear preference for Rust, of course!).</p>\n<p>Please bear with me, here: I am fully _in favor of_ a change in the way we're doing instruction selection, understanding all the benefits, but I am not convinced the proposal in its current state would solve our complexity issues.</p>\n</blockquote>",
        "id": 253704719,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1631865445
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-921623052\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>@bnjbvr thank you for taking the time to detail your concerns here!</p>\n<p>First, at a high level: I'm glad that we agree that some sort of DSL or systematized approach is necessary. The recent string of SIMD-related fuzzbugs, and other difficulties we've had in the past in communicating some of the subtle requirements and invariants in the current handwritten backends (e.g., regalloc metadata, when it is safe to use registers, when it is safe to sink an instruction, and some of the subtle bugs that have resulted when we get this wrong), have convinced me pretty solidly that we need to automate; a handwritten approach, while tempting below a certain level of intrinsic complexity (number of lowering cases / instructions), is just too error-prone.</p>\n<p>There are also the things that we just can't do today, that a systematized DSL would enable: large-scale refactors that alter how the lowering works (e.g., switching to a new regalloc API, or a different emission strategy), combining multiple layers of rewrite rules or manipulating/processing them in some other way (e.g. Peepmatic-style generated simplification patterns), and consuming the lowering patterns for other uses, such as verification. So, in my mind, we need a DSL; the question is just whether this one is the right one.</p>\n<p>If I'm reading your main concerns right, I think they distill down to this -- please correct me if I mis-state anything:</p>\n<ul>\n<li>Discoverability: code written in Rust benefits from all sorts of tooling, and a \"what you see is what you get\" simplicity. Curious how the compiler handles case X? Just trace through the code, or step in a debugger, or \"go to definition\". I agree -- this is great. A DSL adds a level of indirection that makes this harder.</li>\n<li>Complexity of mental model: again in handwritten Rust, we have a \"match on opcode and <code>emit()</code>\" paradigm. ISLE introduces new concepts, in particular around term-rewriting, extractors and constructors, and the like. This is a barrier to entry.</li>\n</ul>\n<p>Both of these are real issues and I think that weighing these against the benefits is largely a subjective question. But I want to dive in a bit on each.</p>\n<p><em>Complexity of mental model</em>: it might be useful to start from a pure term-rewriting system as a neutral, fairly mainstream sort of approach (see e.g. the Go compiler's DSL, or tablegen's expression trees). In your view, is this sort of approach reasonably approachable, or does it suffer from some of the same issues? In other words, I'm trying to distill whether some of the new concepts in ISLE specifically (extractors, single-pass lowering) are the issue, or instead if the issue is just thinking in terms of layered rewrite rules.</p>\n<p>If the former, I think we can definitely try to refine the terminology, or give better examples. If the idea of a programmable extractor in particular is ultimately too weird or objectionable, I can imagine some alternative ways of getting the same thing -- maybe we have constructors on the right-hand side instead that can fail to match. If the latter, and all term-rewriting systems raise concerns, then I think we're at more of a philosophical impasse, since that way of representing instruction lowering is so powerful for all the other things we want to do, but I'm still happy to discuss more :-)</p>\n<p><em>Discoverability</em>: this one is a bit harder, and I agree that pure Rust code is the gold standard w.r.t. discoverable definitions and autocompletions. I do want to note re: your listed advantages above that ISLE, too, is strongly statically typed, unlike a lot of other past term-rewriting systems; so it will at least catch type errors, if not proactively help avoid them in an IDE.</p>\n<p>I'm curious, though, if you have better ideas to address it -- an EDSL in Rust somehow? If so, I'm not sure how we'd be able to do the transforms we want to do -- if you squint enough, the ISLE compiler is sort of doing a \"transpose\", in that it's weaving together a bunch of different lowering-pattern rules by their common prefixes. It's thus a kind of global transform, and would probably need a Rust compiler plugin, rather than just e.g. Rust macros that build data structures, as the cranelift-codegen-meta DSL does. I'm very open to suggestions here.</p>\n<p>Anyway, that's my braindump for now; hopefully we can come to a better consensus here, or at least distill out the subjective decision points that underlie the space!</p>\n</blockquote>",
        "id": 253710120,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1631868528
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-921950669\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi @bnjbvr :)</p>\n<p>First off, I want to recognize that your concerns are valid, particularly around IDEs and developer tooling. I think that is just a fundamental trade off of using a DSL vs open coding, and something we need to explicitly acknowledge and accept if we are going to go down the DSL route.</p>\n<p>Aside: Although embedded (within the \"main\" language) DSLs (EDSLs, as @cfallin mentioned (apologies if you are already familiar with this terminology)) can sometimes have their cake and eat it too with regards to tooling vs DSL. In Rust I think that would probably look like some kind of macro sugar language because I don't think Rust's regular abstraction capabilities would allow us to express the kinds of transformations and combinations of rules that we want to express. However, (a) my experience has been that <code>rust-analyzer</code> isn't great at seeing through macros, and (b) if we use procedural macros (rather than macro-rules macros, which again probably can't do the kinds of transforms/combos we want) then we arguably aren't really doing an EDSL anymore since we are just compiling arbitrary code to Rust in arbitrary ways. So I don't think we can have our cake and eat it too in this particular case.</p>\n<p>All that said, as someone who hasn't contributed to the new backends, I personally find ISLE more inviting than the open-coded backends. Many grains of salt here, since I did some research into Go's/GCC's/etc DSLs for instruction selection and peephole optimizations when designing and implementing Peepmatic, so I've already made myself familiar with this term-rewriting paradigm.</p>\n<p>It was also helpful to step through a few very small examples with @cfallin the other day. We started with just the rule to lower an arbitrary <code>iadd</code>, putting both operands in registers. Then we inspected the generated Rust code. Next, we added rules for if the first operand is an <code>iconst</code> that fits in an immediate and lowered that into an add-with-immediate, and did the same for the second operand. Then we inspected the generated Rust code for these three, partially overlapping rules. This gave me a lot of confidence in the ISLE compiler, and that it is basically doing what I expect it should. I would recommend this exercise to others as well, and I'm happy to pair with people to go through it, if anyone would like.<br>\n</p>\n</blockquote>",
        "id": 253774235,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1631898482
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-922034069\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>As a heads-up, I just added a Cranelift biweekly meeting agenda item to discuss this more -- @bnjbvr, @fitzgen and any others, perhaps we can talk more through these concerns and thoughts then!</p>\n</blockquote>",
        "id": 253796261,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1631907285
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-922034069\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>As a heads-up, I just added a Cranelift biweekly meeting agenda item (edit: for this coming Monday's meeting) to discuss this more -- @bnjbvr, @fitzgen and any others, perhaps we can talk more through these concerns and thoughts then!</p>\n</blockquote>",
        "id": 253796317,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1631907313
    },
    {
        "content": "<p>bnjbvr <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-922998848\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Thanks. As a note, I won't be able to attend this particular meeting because of a conflict.</p>\n</blockquote>",
        "id": 254062169,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1632149402
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-926761957\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Just coordinated briefly with @bnjbvr and have now added an agenda item for the next (Mon Oct 4) Cranelift meeting -- anyone interested in continuing the discussion please feel free to join!</p>\n</blockquote>",
        "id": 254731573,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1632500674
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-933860977\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>FYI, I have added a <a href=\"https://github.com/cfallin/isle#tutorial\">tutorial</a> and <a href=\"https://github.com/cfallin/isle#implementation\">implementation overview</a> to ISLE's <code>README.md</code>.</p>\n</blockquote>",
        "id": 256133913,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1633382067
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[ ] @fitzgen </li>\n<li>[ ] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[ ] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[ ] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 259885934,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635784147
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE in the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/meetings/cranelift/2021/cranelift-11-01.md\">Cranelift biweekly today</a>, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[ ] @fitzgen </li>\n<li>[ ] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[ ] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[ ] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 259886138,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635784229
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE in the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/meetings/cranelift/2021/cranelift-11-01.md\">Cranelift biweekly today</a>, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[x] @fitzgen </li>\n<li>[ ] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[ ] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[ ] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 259886191,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635784263
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956387161\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Fwiw, here are the slides for the update I gave at today's cranelift meeting: <a href=\"https://docs.google.com/presentation/d/1b6psjaIKkVTZGaGzMcw9h_Ahgih-ctUcnz0Dbjn11GI/edit\">https://docs.google.com/presentation/d/1b6psjaIKkVTZGaGzMcw9h_Ahgih-ctUcnz0Dbjn11GI/edit</a></p>\n</blockquote>",
        "id": 259886294,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635784317
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE in the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/meetings/cranelift/2021/cranelift-11-01.md\">Cranelift biweekly today</a>, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @alexcrichton </li>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[x] @fitzgen </li>\n<li>[ ] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[ ] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[ ] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 259887643,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635784948
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956395472\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>(sorry @alexcrichton, just noticed your name was missing -- I had copied the checkbox list from your latest RFC's motion-to-finalize comment. added now!)</p>\n</blockquote>",
        "id": 259887714,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635784991
    },
    {
        "content": "<p>pchickey edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE in the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/meetings/cranelift/2021/cranelift-11-01.md\">Cranelift biweekly today</a>, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @alexcrichton </li>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[x] @fitzgen </li>\n<li>[x] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[ ] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[ ] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 259891648,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635786577
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE in the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/meetings/cranelift/2021/cranelift-11-01.md\">Cranelift biweekly today</a>, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @alexcrichton </li>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[x] @fitzgen </li>\n<li>[x] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[ ] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[x] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 259894018,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635787700
    },
    {
        "content": "<p>tschneidereit edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE in the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/meetings/cranelift/2021/cranelift-11-01.md\">Cranelift biweekly today</a>, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @alexcrichton </li>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[x] @fitzgen </li>\n<li>[x] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[x] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[x] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 260050865,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635883792
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE in the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/meetings/cranelift/2021/cranelift-11-01.md\">Cranelift biweekly today</a>, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[x] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @alexcrichton </li>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[x] @fitzgen </li>\n<li>[x] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[x] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[x] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 260157006,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635955697
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-959773706\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Now that we have signoffs from two separate groups, as per</p>\n<blockquote>\n<p>Once any stakeholder from a different group has signed off, the RFC will move into a 10 calendar day final comment period (FCP), long enough to ensure that other stakeholders have at least a full business week to respond.</p>\n</blockquote>\n<p>we are moving into the <strong>Final Comment Period</strong>. The FCP will end on Monday, November 15.</p>\n</blockquote>",
        "id": 260170831,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635961536
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-968875811\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>This is OK with me.</p>\n</blockquote>",
        "id": 261491774,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1636980354
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE in the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/meetings/cranelift/2021/cranelift-11-01.md\">Cranelift biweekly today</a>, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[x] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @alexcrichton </li>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[x] @fitzgen </li>\n<li>[x] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[x] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[x] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[x] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 261518775,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1636992519
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-969066812\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- now that the Final Comment Period has elapsed and there are no pending objections, it is time to merge this RFC!</p>\n<p>The next step will be review and landing of the initial code itself. I plan to put together some language-reference-like documentation for the DSL itself, and I'm happy to help answer questions and onboard folks in general as we transition the codegen backends to this new approach!</p>\n</blockquote>",
        "id": 261519092,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1636992658
    },
    {
        "content": "<p>akirilov-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/15#issuecomment-956384950\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">issue #15</a>:</p>\n<blockquote>\n<p>Hi all -- thanks for the continuing input and patience on this long-running effort!</p>\n<p>@fitzgen gave an excellent update on his progress driving forward the prototype Cranelift integration for ISLE in the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/meetings/cranelift/2021/cranelift-11-01.md\">Cranelift biweekly today</a>, and example implementations of several instruction lowerings. The general consensus from the meeting was that there are no strong objections to moving forward with this. So, with that in mind, I would like to make a...</p>\n<h1>Motion to finalize with a disposition to merge</h1>\n<h1>Stakeholders sign-off</h1>\n<h2>Arm</h2>\n<ul>\n<li>[x] @akirilov-arm</li>\n<li>[x] @sparker-arm</li>\n</ul>\n<h2>DFINITY</h2>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h2>Embark Studios</h2>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h2>Fastly</h2>\n<ul>\n<li>[x] @alexcrichton </li>\n<li>[x] @cfallin</li>\n<li>[ ] @sunfishcode </li>\n<li>[x] @fitzgen </li>\n<li>[x] @pchickey </li>\n<li>[ ] @peterhuene </li>\n<li>[ ] @acfoltzer </li>\n<li>[ ] @iximeow </li>\n<li>[ ] @aturon </li>\n<li>[ ] @cratelyn </li>\n<li>[x] @tschneidereit </li>\n</ul>\n<h2>Google/Envoy</h2>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h2>Intel</h2>\n<ul>\n<li>[ ] @mingqiusun</li>\n<li>[ ] @abrown </li>\n<li>[ ] @jlb6740</li>\n</ul>\n<h2>Microsoft</h2>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h2>Mozilla</h2>\n<ul>\n<li>[ ] @julian-seward1 </li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h2>IBM</h2>\n<ul>\n<li>[x] @uweigand</li>\n</ul>\n<h2>wasmCloud</h2>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h2>Unaffiliated</h2>\n<ul>\n<li>[x] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 261522561,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1636994009
    }
]