[
    {
        "content": "<p>abrown opened <a href=\"https://github.com/bytecodealliance/rfcs/pull/41\">PR #41</a> from <code>abrown:cranelift-assembler</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p><a href=\"https://github.com/abrown/bytecodealliance-rfcs/blob/cranelift-assembler/accepted/cranelift-assembler.md\">Rendered</a></p>\n</blockquote>",
        "id": 487360419,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733874839
    },
    {
        "content": "<p>programmerjake submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2494061501\">PR review</a>.</p>",
        "id": 487995014,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733879766
    },
    {
        "content": "<p>programmerjake created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1879168537\">PR review comment</a>:</p>\n<blockquote>\n<p>I think it would be useful for these to be trait methods that way generic code isn't required to use the full <code>enum Inst</code> along with the probable code bloat (from having a match arm for every instruction even if we're only using one or a few) that implies.</p>\n</blockquote>",
        "id": 487995015,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733879766
    },
    {
        "content": "<p>programmerjake edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1879168537\">PR review comment</a>.</p>",
        "id": 487995039,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733879782
    },
    {
        "content": "<p><strong>abrown</strong> has marked <a href=\"https://github.com/bytecodealliance/rfcs/pull/41\">PR #41</a> as ready for review.</p>",
        "id": 487996989,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733881001
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2494102749\">PR review</a>:</p>\n<blockquote>\n<p>Thanks a ton for writing this up! It's been really neat to see the DSL come together; I think it's a very clean and powerful way of spec'ing the ISA we support, should reduce potential for errors, and will result in a more generic and reusable assembler library.</p>\n<p>I may have more thoughts later but I wanted to write out my thoughts on what I see as the most important point below:</p>\n</blockquote>",
        "id": 487998080,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733881712
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1879197632\">PR review comment</a>:</p>\n<blockquote>\n<p>This is a difficult problem to be sure. I want to write out our understanding (or at least \"my understanding of our understanding\") of the situation here, so the tradeoffs are clear at least:</p>\n<ul>\n<li>Cranelift lowers into an IR that looks <em>almost</em> like machine code, except for two aspects: register operands are virtual register numbers, and register operands are in SSA form. This is because our regalloc operates on SSA input with constraints (and this for good reasons -- e.g. it avoids the need for a \"defensive copy\" on every two-reg instruction's src/dst, which we hope is elided later).</li>\n<li>We call this pre-regalloc form \"VCode\" and, properly speaking, it is a separate IR -- not CLIF, not machine code. (Lowering takes CLIF to VCode and regalloc takes VCode to \"machine code\", which we represent in the <code>VCode</code> struct as well but that's not important here.)</li>\n<li>To avoid significant duplication, because VCode is so close to machine code (aside from those two differences above), we overload our current \"machine instruction\" definitions to (i) contain <code>Reg</code>s that can hold vregs or real regs, and (ii) always be in three-reg form, even on x86, with separate \"dest-side\" operands for R+W real operands. In other words, we've basically defined an IR that is a <em>union</em> of machine code and VCode so that we can use one representation.</li>\n<li>This union-based approach has performance advantages as well: because one IR is almost another, and because of the way the overloading is done (in individual operand slots), we can edit in place to turn one into another.</li>\n</ul>\n<p>So here's the difficulty (and here is where my analysis and opinion starts): an assembler library that wants to stay as close as possible to \"machine code\" will naturally not have an instruction representation that is a <em>superset</em> of machine code and VCode. But if we only have machine instructions, then Cranelift needs to keep VCode around with an instruction enum -- in other words, we aren't deleting any code, we're just adding another instruction representation to maintain, and a lowering step from one to the other, and the performance cost of that too. IMHO this is a nonstarter and means that we need to design the library to accomodate \"in-place representation\" of pre-regalloc state.</p>\n<p>There are two general paths here: generic and specific.</p>\n<ul>\n<li>\n<p>The generic path is to have a pluggable notion of operand, with a trait that allows the assembler library to get the physical register name out of it once it's in its final state. An operand for x86 might actually hold two vreg numbers (for a read-modify-write inst, i.e. one use for the \"input side\" and one def for the \"output side\", constrained together) or one; and will hold a sum type that is either a vreg or real reg. But that's the concern of the user of the library; someone else could equally plug in a <code>u8</code> with a stub trait impl and call it a day (and we can provide this default impl).</p>\n<p>The upside of this approach is that it is clean and keeps Cranelift/VCode/regalloc abstractions out of the assembler library, as you state here; and makes the library more reusable for others too. (E.g., Winch probably doesn't care about vreg numbers or SSA use/def distinction.) The downside is that it adds trait/type-param/constraint soup everywhere.</p>\n</li>\n<li>\n<p>Specific: choose one implementation (\"two <code>u32</code> vregs for R/W, one <code>u32</code> vreg otherwise\" seems OK). Basically this is the above but with one trait impl inlined in, if we decide the trouble isn't worth it.</p>\n</li>\n</ul>\n<p>Those are the two main options I see; I can't see how we are able to delete the existing VCode inst enum otherwise, since fundamentally we need to store the SSA representation of instructions somehow.</p>\n<p>I know we explored the generic thing earlier and decided it was getting a little gnarly, but as I write out the above I seem to be convincing myself down that path again -- maybe we could try it now that you've gotten over the hurdle of an initial PoC? Would be interested in what others think as well!</p>\n</blockquote>",
        "id": 487998082,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733881712
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2497031402\">PR review</a>.</p>",
        "id": 488190390,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733951932
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1881017403\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>and (ii) always be in three-reg form, even on x86, with separate \"dest-side\" operands for R+W real operands</p>\n</blockquote>\n<p>To ask a question about this, IIRC this was because register allocation was so much easier when read/write operands were removed. Is that still the case? For example does <code>regalloc2</code> (and <code>regalloc3</code>?) not support register allocation on the \"native x86 form\"?</p>\n</blockquote>",
        "id": 488190391,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733951932
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2497035034\">PR review</a>.</p>",
        "id": 488190725,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733952064
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1881019641\">PR review comment</a>:</p>\n<blockquote>\n<p>One thing I'd be curiuos to see, especially in connection with the verbosity point called out below, is how this would integrate into the lowering of <code>band</code> itself at a high level. For example the lowerings we have today feel \"right\" to me in that they use <code>(x64_and ...)</code> as the result. I think it'd be reasonable to rename <code>x64_and</code> to <code>x64_andl_mi_xsbl ...</code> or such to avoid shoehorning so many instructions into one shape (which I think is a good idea), but with this ISLE snippet I don't know what the output of <code>AssemblerGprMem</code> is and how that'd get integrated into the <code>band</code> lowering. </p>\n</blockquote>",
        "id": 488190726,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733952064
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2497044412\">PR review</a>.</p>",
        "id": 488191643,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733952408
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1881025226\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, absolutely, and we should not go back. (There was a huge effort, months of work mainly by @elliottt, to finish the SSA transition because of this.)</p>\n<p>I touched on the main point above but basically, if we register-allocate on native x86 form, we lean very heavily on bundle-merging and move-elision to get back to ideal form, because we have to make a copy of every src1 operand before the instruction. Moving back to this approach would lead to a significant regression in compile time and also probably code-quality issues where our merging heuristics aren't good enough.</p>\n<p>We also simplify many other aspects of the register allocator. For example, with SSA we can now do \"overlapping liveranges\" (because a value is defined only once, we can reason about multiple copies more easily), which unlocks other performance ideas (already, and more in the future potentially).</p>\n<p>For what it's worth, our approach was inspired by IonMonkey's register allocator, which also operates on strict SSA with special constraints to deal with the x86-ism of \"the output reg must also be this input reg, and clobbers it\". We previously thought we should do the native thing; that was <code>regalloc.rs</code>; we learned from it and then reverted to this approach.</p>\n<hr>\n<p>Separately, I think there's a question of how to make an assembler library most useful. It could be very opinionated about what is acceptable in an instruction, or it could offer flexibility in operand formats; I suspect Cranelift is not the only potential user with special requirements around what goes into an operand, or metadata around it. To maximize its usefulness, IMHO it should offer a pluggable <code>T: Operand</code> and then we can do all the SSA stuff on the Cranelift side.</p>\n</blockquote>",
        "id": 488191644,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733952408
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2497054426\">PR review</a>.</p>",
        "id": 488192451,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733952715
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1881031192\">PR review comment</a>:</p>\n<blockquote>\n<p>Ok cool mostly wanted to confirm that \"must be ssa form\" is still a hard constraint. </p>\n<p>I understand the desire to have the assembler library be as simple as possible and as close to the spec as possible, but I also agree that this constraint will force our hand in doing something above-and-beyond the \"Rust translation of the intel manual\". I don't personally have an opinion on <code>T: Operand</code> vs \"just inline <code>T = CraneliftX64Operand</code> everywhere\".</p>\n</blockquote>",
        "id": 488192452,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733952715
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2497214450\">PR review</a>.</p>",
        "id": 488517919,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733958144
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1881135275\">PR review comment</a>:</p>\n<blockquote>\n<p>One slight refinement to <code>T: Operand</code> that I want to write down here as it occurs to me: we probably want something like <code>Inst&lt;R: ReadOperand, W: WriteOperand&gt;</code> or <code>Inst&lt;R: ReadOperand, W: WriteOperand, M: ModOperand&gt;</code> so that the user can plug in different things for each: e.g. the Cranelift x64 backend wants one <code>u32</code> for <code>R</code> and <code>W</code> and two <code>u32</code>s for <code>M</code>. We could also potentially integrate that with the regalloc visitor (trait <code>Visitor</code> has <code>fn visit_read(&amp;mut R)</code>, <code>fn visit_write(&amp;mut W)</code>, <code>fn visit_mod(&amp;mut M)</code>).</p>\n</blockquote>",
        "id": 488517920,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1733958145
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2506563931\">PR review</a>:</p>\n<blockquote>\n<p>I am in favor of the overall plan and goals, but I do have concerns, nitpicks, and bikesheds on some details.</p>\n<p>Two things that could be nice to plan for and make sure we aren't accidentally making harder than they otherwise should be, even if we don't intend to implement their support in the DSL initially, are:</p>\n<ol>\n<li>\n<p>Flagging which instructions are available on 32-bit <code>x86</code>, not just <code>x86_64</code> and whatever ISA extensions, to make an eventual <code>x86</code> backend that much easier and able to reuse all these instruction definitions, instead of needing to subset them.</p>\n</li>\n<li>\n<p>A way to attach ISLE specs to the instructions in the DSL so we can better integrate with the ISLE verification effort.</p>\n</li>\n</ol>\n<p>Finally, thanks for investigating and prototyping what a better mach inst looks like! I am excited to clean this stuff up.</p>\n</blockquote>",
        "id": 489278034,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734365554
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887063750\">PR review comment</a>:</p>\n<blockquote>\n<p>One thing I don't see discussed (thus far, at least) is how the DSL is parsed and how this code is generated. We need to be careful about adding compile time overhead to Cranelift (and Wasmtime, and every downstream crate using Cranelift).</p>\n<p>For example, we should <em>not</em> encode the DSL in toml or yaml and require a new build-dep for parsing that markup language. Nor should we write our own parser for the DSL that has to be built and run from <code>build.rs</code>.</p>\n<p>The only realistic approach that I am aware of that satisfies this constraint is a <code>for_each_instruction!</code>-style macro, or macros, similar to what Pulley does for its instruction set. This reuses the Rust compiler's parsing facilities to avoid spending compile/build time on DSL parsers and we can also generate only what is needed for different use cases by <code>cfg</code>ing different invocations of the macro on and off as necessary (e.g. if we only need the encoders and not the pretty printers for a particular build configuration).</p>\n</blockquote>",
        "id": 489278035,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734365554
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887047628\">PR review comment</a>:</p>\n<blockquote>\n<p>bikeshed: If <code>andb</code> isn't even enough on its own, and we have to break ties by concatenating additional metadata, then can we use ~intel syntax instead of ~att syntax? Regardless of flavor any one person is used to, using intel syntax makes cross referencing with the official manual that much easier.</p>\n</blockquote>",
        "id": 489278039,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734365554
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887095471\">PR review comment</a>:</p>\n<blockquote>\n<p>I think ideally we want to move everything over towards something like whatever we end up at here. I don't think everything needs to use exactly the same machinery, but the motivation for x64 applies pretty much to every backend.</p>\n<p>We also don't have to do the migration en masse, all at once, and before experimenting with just the x64 backend. We can do things in an incremental fashion and learn what works well and what doesn't as we go.</p>\n</blockquote>",
        "id": 489278041,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734365554
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887090655\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this is also touching on the tension/impedance mismatch between \"assembler library that directly reflects <code>x86_64</code>\" and \"final machine-specific backend IR for Cranelift\". At the ISLE lowering rules level, I don't want to think about formats at all. I want to think about whole instructions and that's it. At the register operand collection and encoding levels, I don't care so much about whole instructions, and formats can be great shortcuts for deduplicating code.</p>\n<p>I think we should prioritize and optimize for ISLE lowering rules. The latter things will ideally be automatically generated from the DSL describing the instructions, and so the duplication aspect doesn't affect our maintenance burden (although it admittedly could affect Cranelift's run time performance, the time it takes to build Cranelift, and the size of a Cranelift binary; nonetheless I'm not too concerned in this case).</p>\n</blockquote>",
        "id": 489278042,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734365554
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2506673559\">PR review</a>.</p>",
        "id": 489279807,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734365976
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887116789\">PR review comment</a>:</p>\n<blockquote>\n<p>If core assembler library just contains the DSL, and the DSL isn't actually generating an instruction <code>enum</code> itself, then it seems like the assembler library can punt these questions to its downstream users? And then we can generate an instruction <code>enum</code> in Cranelift that supports the SSA stuff, and other users can generate an instruction <code>enum</code> (if they even need one) that does not. In Cranelift, the generated encoding functions will need to dynamically assert that the first operand and destination operand are the same register for the two-operand instructions, but we have to do that today already.</p>\n<p>This approach avoids adding generics to the instruction <code>enum</code> itself. (Depending on how we do encoding functions and what not, we may need generics on those functions and we may need to implement one or more traits for the instruction <code>enum</code>, but the <code>enum</code> itself need not be generic over some <code>T: Operand</code>).</p>\n</blockquote>",
        "id": 489279809,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734365977
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2506758673\">PR review</a>.</p>",
        "id": 489287753,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734367907
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887171392\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>If core assembler library just contains the DSL, and the DSL isn't actually generating an instruction enum itself, then it seems like the assembler library can punt these questions to its downstream users? And then we can generate an instruction enum in Cranelift that supports the SSA stuff, and other users can generate an instruction enum (if they even need one) that does not. In Cranelift, the generated encoding functions will need to dynamically assert that the first operand and destination operand are the same register for the two-operand instructions, but we have to do that today already.</p>\n</blockquote>\n<p>The way that Andrew's prototype works at least, the instruction enum is generated by the assembler library. And this seems pretty essential to its value IMHO -- we don't want to be in the business of maintaining a separate list of instructions for each target in Cranelift.</p>\n<p>Said another way: the underlying situation is fundamentally parameterized: Cranelift wants \"an enum for x86 instructions, except with these details for operands\". Knowledge of x86 should live in the assembler library (else it would be only a meta-assembler library to \"build your own assembler\"); and knowledge of operand details should live in the embedder. That calls out for pluggable details, i.e. generics.</p>\n<p>Briefly unfolding that \"meta-assembler\" thought: I think what you might have in mind is a library with the DSL abstractions and framework for emission, but all the instruction definitions living in the embedder? That is also a design point but not one that is globally best even within our own repo IMHO: we want Winch to be able to benefit from the assembler's x86 knowledge (as it does from Cranelift's <code>MachInst</code>s today), so we want the assembler layer itself to be self-contained.</p>\n</blockquote>",
        "id": 489287756,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734367907
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887171392\">PR review comment</a>.</p>",
        "id": 489287882,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734367931
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2506882717\">PR review</a>.</p>",
        "id": 489299426,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734371192
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887253058\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>For example, we should not encode the DSL in toml or yaml and require a new build-dep for parsing that markup language. Nor should we write our own parser for the DSL that has to be built and run from <a href=\"http://build.rs\">build.rs</a>.</p>\n</blockquote>\n<p>Personally I'd push back on this and say that whether or not this is acceptable is a function of the various other tradeoffs in play. While we should be cognizant of compile time I don't think we should take a policy of \"this can't land unless it has 0 compile-time regressions\" and instead balance the compile time with the maintainability win (and other motivations) in this RFC</p>\n</blockquote>",
        "id": 489299427,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734371193
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2506890992\">PR review</a>.</p>",
        "id": 489300251,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734371438
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887258637\">PR review comment</a>:</p>\n<blockquote>\n<p>@fitzgen it sounds like you're advocating for a Pulley-style approach where all instructions are part of a macro invocation so callers can customize the generated code by customizing what the macro generates, is that right? If so personally I don't think that's the right approach for platforms other than Pulley which have non-Rust definitions. There's also tradeoffs to the macro-based approach in Rust so I don't think it's a clear win either. Personally I'd find a \"this is just an assembler library\" approach with generics more palatable than a <code>for_each_x86_op!(...)</code> macro generated from Intel's definitions of instructions.</p>\n</blockquote>",
        "id": 489300252,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734371438
    },
    {
        "content": "<p>abrown submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2507619672\">PR review</a>.</p>",
        "id": 489375359,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734395567
    },
    {
        "content": "<p>abrown created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887743896\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, agreed that we want everything to easily cross-reference. If there's anything that isn't like that it's probably due to how I set up Capstone, which we end up mimic-ing. Is there something specific here you were thinking of? Operand ordering? Suffixes?</p>\n</blockquote>",
        "id": 489375360,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734395567
    },
    {
        "content": "<p>abrown submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2507623370\">PR review</a>.</p>",
        "id": 489375756,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734395790
    },
    {
        "content": "<p>abrown created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887746335\">PR review comment</a>:</p>\n<blockquote>\n<p>Maybe it's not super clear in the text, @fitzgen, but there is no new parsing or markup language involved here. I think I would have preferred a true DSL but, based on your initial recommendation, I just use Rust code in a <code>meta</code> crate much like we do in <code>cranelift-codegen-meta</code>. So the DSL is made up of Rust helper functions that create the \"AST\" &mdash; no additional build dependencies required.</p>\n</blockquote>",
        "id": 489375757,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734395790
    },
    {
        "content": "<p>abrown submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2507641331\">PR review</a>.</p>",
        "id": 489378102,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734397011
    },
    {
        "content": "<p>abrown created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887759005\">PR review comment</a>:</p>\n<blockquote>\n<p>I'm not sure I completely understand what you mean: let's talk about \"categories.\" <code>x64_and</code> is a category of instructions, not an x64 instruction. <code>x64_andb</code>, despite being more specific, is also a category of instructions. <code>x64_andb_mi</code> is an actual instruction. I interpret your comment about formats to actually echo something @cfallin and I have talked about, which is that actually in ISLE we _do_ want to use categories, e.g., <code>x64_and</code>. Is that what you mean?</p>\n</blockquote>",
        "id": 489378103,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734397011
    },
    {
        "content": "<p>abrown submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#pullrequestreview-2507660430\">PR review</a>.</p>",
        "id": 489380307,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734398164
    },
    {
        "content": "<p>abrown created <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887770191\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, this is something discussed below in the \"verbosity\" bullet. Let me provide more detail by just focusing in on the 8-bit version of CLIF <code>and</code>; in <code>cranelift-codegen</code>, we have three possibilities for each of the operands, <code>x</code> and <code>y</code>, to this CLIF instruction. I wrote out all the possible options and thought through how we might lower them:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">~</span><span class=\"n\">x</span><span class=\"o\">~</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">~</span><span class=\"n\">y</span><span class=\"o\">~</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">asm</span><span class=\"w\">             </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">notes</span><span class=\"w\">                      </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"o\">|------+-----+-----+-----------------+----------------------------+------|</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">I8</span><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Gpr</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Gpr</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">andb_rm</span><span class=\"o\">/</span><span class=\"n\">andb_mr</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">                            </span><span class=\"o\">|</span><span class=\"w\">    </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">I8</span><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Gpr</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Mem</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">andb_rm</span><span class=\"w\">         </span><span class=\"o\">|</span><span class=\"w\">                            </span><span class=\"o\">|</span><span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">I8</span><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Gpr</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Imm</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">andb_mi</span><span class=\"o\">/</span><span class=\"n\">andb_i</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">                            </span><span class=\"o\">|</span><span class=\"w\">    </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">I8</span><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Mem</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Gpr</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">andb_rm</span><span class=\"w\"> </span><span class=\"n\">flipped</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">                            </span><span class=\"o\">|</span><span class=\"w\">    </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">I8</span><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Mem</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Mem</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">                 </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">No</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cannot</span><span class=\"w\"> </span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\">     </span><span class=\"o\">|</span><span class=\"w\">      </span><span class=\"o\">|</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">I8</span><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Mem</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Imm</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">andb_mi</span><span class=\"w\">         </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">No</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">modified</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">      </span><span class=\"o\">|</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">I8</span><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Imm</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Gpr</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">andb_mi</span><span class=\"w\"> </span><span class=\"n\">flipped</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">                            </span><span class=\"o\">|</span><span class=\"w\">    </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">I8</span><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Imm</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Mem</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">andb_mi</span><span class=\"w\"> </span><span class=\"n\">flipped</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">No</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">modified</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">      </span><span class=\"o\">|</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">I8</span><span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Imm</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Imm</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">                 </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">No</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cannot</span><span class=\"w\"> </span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\">     </span><span class=\"o\">|</span><span class=\"w\">      </span><span class=\"o\">|</span>\n</code></pre></div>\n<p>Some options we just can't encode in x64. Other's we can't yet (we need to be pattern-match a read+write to a single memory location). But for the five options we _can_ encode, let's write out some ISLE rules:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">has_type</span><span class=\"w\"> </span><span class=\"cp\">$I8</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">band</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ensure_in_vreg</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ensure_in_vreg</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">))))</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">x64_andb_rm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">has_type</span><span class=\"w\"> </span><span class=\"cp\">$I8</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">band</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ensure_in_vreg</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">sinkable_load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">))))</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">x64_andb_rm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">has_type</span><span class=\"w\"> </span><span class=\"cp\">$I8</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">band</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ensure_in_vreg</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">simm32_from_value</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">))))</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">x64_andb_mi</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">has_type</span><span class=\"w\"> </span><span class=\"cp\">$I8</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">band</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">sinkable_load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ensure_in_vreg</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">))))</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">x64_andb_rm</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">has_type</span><span class=\"w\"> </span><span class=\"cp\">$I8</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">band</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">simm32_from_value</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ensure_in_vreg</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">))))</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">x64_andb_mi</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">))</span>\n</code></pre></div>\n<p>Let's pretend that <code>ensure_in_vreg</code> means \"this is a <code>Gpr</code>,\" <code>sinkable_load</code> means \"this is a <code>Mem</code>,\" and ~simm32_from_value~ means \"this is an <code>Imm</code>\" (to reuse some existing ISLE helpers). Turns out there are a few other patterns we can probably encode as well that additionally pattern-match on sign extension.</p>\n<p>Two observations from this:</p>\n<ul>\n<li>if we lower at this level, it is _very_ verbose (multiply those rules times more sizes!); this is what I'm requesting discussion on in the \"verbose\" section below</li>\n<li>this is also very clear: one can see that we just can't lower certain patterns as well as what is the precise instruction emitted for each pattern that we can</li>\n</ul>\n<hr>\n<p>Hope all of that connects the dots for how one might verbosely lower to the assembler instructions. But, of course, if we want to retain the existing meta-rules like <code>x64_and</code> then we can probably generate those somehow as well. I'm fine with either approach.</p>\n</blockquote>",
        "id": 489380308,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734398164
    },
    {
        "content": "<p>abrown edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/41#discussion_r1887770191\">PR review comment</a>.</p>",
        "id": 489380339,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1734398189
    }
]