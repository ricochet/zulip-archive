[
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-952180307\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<p>@cfallin Thanks for the feedback! Concerning your general questions:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>* It might be good to add a little more detail here to describe proposed changes to the generated code. In particular more detail on the pointer-auth would be helpful, just to document our approach if nothing else.\n</code></pre></div>\n\n</blockquote>\n<p>Sure, I can use a simple CLIF function that just calls another subroutine and returns immediately after that as an example, and present the generated code before and after the CFI enhancements.</p>\n<p>In the meantime, the <a href=\"https://community.arm.com/arm-community-blogs/b/tools-software-ides-blog/posts/code-reuse-attacks-the-compiler-story\">article</a> that is mentioned in the text actually provides that level of detail, to help with the discussion before I update the proposal.</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>* Do either of these features (especially pointer-auth) affect the ABI (I don&#39;t actually know)?\n</code></pre></div>\n\n</blockquote>\n<p>The scheme that I have described in the proposal should be mostly backward compatible, that is any part of the program should be able to remain oblivious of whether some code it interacts with uses PAuth and/or BTI or not. The major exceptions are unwinders, but at least the system ones should be prepared to deal with PAuth (assuming that the software environment the application runs in is relatively recent and that the suggested DWARF changes are implemented), as <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3183\">bytecodealliance/wasmtime#3183</a> has demonstrated in an unpleasant way. Of course, I can add a short paragraph that summarizes the backward compatibility aspect to the proposal.</p>\n<p>However, it is possible to devise more sophisticated CFI schemes that require the introduction of specialized ABIs and that have a potentially higher performance overhead - for example, <a href=\"https://github.com/apple/llvm-project/blob/next/clang/docs/PointerAuthentication.rst#language-abi\">Apple's own variant</a>. IMHO we should start with something simple that will allow us to work out the interactions with the rest of the system, while providing a reasonable improvement to CFI.</p>\n</blockquote>",
        "id": 259136769,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635271313
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-956441522\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<p>It seems like supporting pointer authentication and BTI is largely an implementation detail of the aarch64 backend, and doesn't require new clif instructions or larger compiler/runtime changes (other than support for configuring aarch64-specific codegen options). Is my understanding correct here?</p>\n<blockquote>\n<p>The proposed implementation will add the PACIASP instruction to the beginning of every function compiled by Cranelift and would replace the final return with the RETAA instruction.</p>\n</blockquote>\n<p>Two questions:</p>\n<ul>\n<li>\n<p>Should we have support for both the nop versions of these instructions _and_ the non-nop versions? (<code>RETA{A,B}</code> are non-nop IIUC.) And should we expose whether to use the non-nop versions as a cranelift settings option?</p>\n</li>\n<li>\n<p>Similarly, should we support both the <code>a</code> key and <code>b</code> key? Does userspace always use <code>a</code> by convention? If so, then we can probably get away without the option to generate <code>b</code>.</p>\n</li>\n</ul>\n<blockquote>\n<p>These steps can be skipped for simple leaf functions that do not construct frame records on the stack.</p>\n</blockquote>\n<p>LLVM has an option to generate the pointer auth for leaf functions, do we want to as well?<br>\n</p>\n</blockquote>",
        "id": 259895450,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1635788440
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-983524158\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<p>I think @alexcrichton asked how the Rust compiler planned to use PAuth and BTI during one of the Cranelift meetings - details are in <a href=\"https://github.com/rust-lang/rust/issues/88354\">rust-lang/rust#88354</a>; the changes seem to follow what GCC and LLVM are already doing.</p>\n<p>As for @fitzgen's questions:</p>\n<blockquote>\n<p>It seems like supporting pointer authentication and BTI is largely an implementation detail of the aarch64 backend, and doesn't require new clif instructions or larger compiler/runtime changes (other than support for configuring aarch64-specific codegen options). Is my understanding correct here?</p>\n</blockquote>\n<p>Yes, it is, but the main reason I have posted a RFC is to discuss the higher-level points such as whether the proposed hardening makes sense and what the extent of the threat model should be, e.g. we may decide that a CFI mechanism that requires ABI changes, while being beyond the scope of the current proposal, is something that we should definitely consider in the future. The discussion should also inform a potential x86 implementation using CET.</p>\n<blockquote>\n<p>Should we have support for both the nop versions of these instructions _and_ the non-nop versions?</p>\n</blockquote>\n<p>Keeping in mind that PAuth can't be enabled in a granular way (e.g. with IFUNC or a similar mechanism), but it has to be used globally in all functions in order to be effective, the main utility of the <code>NOP</code> versions of the instructions is to ease deployment and in particular to support the Linux distribution use case, where the OS vendors would like to ship a single set of binaries that would still be hardened on compatible hardware. I believe that this is not really relevant to Wasmtime, so the current proposal minimizes the size of the generated code, but I might be wrong, hence I added the open question - please, chime in if that's indeed the case.</p>\n<p>However, if we consider the <code>cg_clif</code> use case, then we might in fact need to support both versions of the instructions - the <code>NOP</code> variants that would be used by Cranelift as a Rust compiler backend and the rest for Wasmtime. @bjorn3, since you are driving the former use case, I would appreciate any comments.</p>\n<blockquote>\n<p>Similarly, should we support both the <code>a</code> key and <code>b</code> key? Does userspace always use <code>a</code> by convention?</p>\n</blockquote>\n<p>AFAIK there isn't a convention _per se_ and applications are free to use both keys, but most software is probably going to use the A key because it is the default for static compilers such as GCC. However, one option that has been discussed in the context of programs that use JIT compilation (e.g. dynamic language runtimes) is to use the B key for generated functions and the A key for statically compiled code.</p>\n<p>Also, the same interoperability considerations with the Rust compiler apply here.</p>\n<blockquote>\n<p>LLVM has an option to generate the pointer auth for leaf functions, do we want to as well?</p>\n</blockquote>\n<p>I suppose you mean all leaf functions as opposed to those that are not affected by the optimization introduced by <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2960\">bytecodealliance/wasmtime#2960</a>, which is what the text currently proposes (does LLVM make that distinction)? Again, that would mostly be about being able to accommodate whatever the Rust compiler decides to do.</p>\n</blockquote>",
        "id": 263273143,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1638356334
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-983565895\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<blockquote>\n<p>However, if we consider the <code>cg_clif</code> use case, then we might in fact need to support both versions of the instructions - the <code>NOP</code> variants that would be used by Cranelift as a Rust compiler backend and the rest for Wasmtime.</p>\n</blockquote>\n<p>I wonder if this might also be relevant for scenarios where <code>wasmtime compile</code> is used, and the resulting <code>.cwasm</code> file deployed to other machines. While it seems highly advisable to ensure those deployment scenarios involve pretty tight control over the target configuration, it still seems like there might be value in enabling the <code>.cwasm</code> file to run on a broader range of hardware.</p>\n</blockquote>",
        "id": 263278313,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1638359557
    },
    {
        "content": "<p>bnjbvr <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-983646947\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<blockquote>\n<p>Similarly, should we support both the a key and b key? Does userspace always use a by convention?</p>\n<p>AFAIK there isn't a convention per se and applications are free to use both keys, but most software is probably going to use the A key because it is the default for static compilers such as GCC. However, one option that has been discussed in the context of programs that use JIT compilation (e.g. dynamic language runtimes) is to use the B key for generated functions and the A key for statically compiled code.</p>\n</blockquote>\n<p>Some relevant documentation about the choice of using the A or B keys for signing pointers, according to LLVM's (maybe Apple's LLVM fork _in particular_) documentation of pointer authentication: <a href=\"https://github.com/apple/llvm-project/blob/next/clang/docs/PointerAuthentication.rst#key-assignments\">https://github.com/apple/llvm-project/blob/next/clang/docs/PointerAuthentication.rst#key-assignments</a></p>\n<p>In particular, I do confirm seeing B key be used for signing return addresses on Mac M1.</p>\n<p>If I understand correctly, for the particular case of the return address at least, the selected key has to match what the host system has chosen too. When unwinding the stack on Mac M1 (when creating a backtrace for an error, for instance), the system's libunwind tried to authenticate all return addresses with the B key, including return addresses that had been stored in registers/stack by Cranelift-generated code. Does that sound accurate? If so, would that require having low-level settings that controlled which key is used in which particular context (e.g. \"use the B key for signing return addresses\"), or is it something that can be configured during unwinding through the use of CFI directives?</p>\n</blockquote>",
        "id": 263290211,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1638365674
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-984963550\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<blockquote>\n<p>... according to LLVM's (maybe Apple's LLVM fork _in particular_) documentation of pointer authentication...</p>\n</blockquote>\n<p>To be precise - this concerns <code>arm64e</code>, Apple's pointer authentication ABI variant, which is incompatible with its predecessor, while the proposal here discusses an approach that interoperates mostly transparently with vanilla AAPCS64.</p>\n<p>However, thanks for pointing that out because it means that we may need to do something different when targetting macOS. I have to admit that my previous answer (and, indeed, the proposal itself) has been written mostly with Linux in mind.</p>\n<blockquote>\n<p>... for the particular case of the return address at least, the selected key has to match what the host system has chosen too. When unwinding the stack on Mac M1 [...], the system's libunwind tried to authenticate all return addresses with the B key, including return addresses that had been stored in registers/stack by Cranelift-generated code. Does that sound accurate?</p>\n</blockquote>\n<p>Yes, it makes sense.</p>\n<blockquote>\n<p>If so, would that require having low-level settings that controlled which key is used in which particular context (e.g. \"use the B key for signing return addresses\"), or is it something that can be configured during unwinding through the use of CFI directives?</p>\n</blockquote>\n<p>Well, considering the Linux/DWARF case, the key <a href=\"https://github.com/ARM-software/abi-aa/blob/320a56971fdcba282b7001cf4b84abb4fd993131/aadwarf64/aadwarf64.rst#43common-information-entries\">could</a> actually be specified in the CIE via a CIE augmentation string.</p>\n</blockquote>",
        "id": 263494049,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1638475768
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-996017063\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<p>@tschneidereit</p>\n<blockquote>\n<blockquote>\n<p>However, if we consider the <code>cg_clif</code> use case, then we might in fact need to support both versions of the instructions - the <code>NOP</code> variants that would be used by Cranelift as a Rust compiler backend and the rest for Wasmtime.</p>\n</blockquote>\n<p>I wonder if this might also be relevant for scenarios where <code>wasmtime compile</code> is used, and the resulting <code>.cwasm</code> file deployed to other machines. While it seems highly advisable to ensure those deployment scenarios involve pretty tight control over the target configuration, it still seems like there might be value in enabling the <code>.cwasm</code> file to run on a broader range of hardware.</p>\n</blockquote>\n<p>While I was writing the proposal, my assumption was that even if Wasmtime compiled a Wasm module ahead-of-time, the machine on which the generated code executed would usually have the same (or better) capabilities than those enabled during compilation. How important is the opposite use case? @cfallin also <a href=\"https://github.com/bytecodealliance/rfcs/pull/17/files#r736731923\">expressed</a> some reservations about the overhead of the additional instructions, so machines without PAuth support would probably rather avoid them.</p>\n</blockquote>",
        "id": 265187682,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1639674919
    },
    {
        "content": "<p>akirilov-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-996017063\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<p>@tschneidereit</p>\n<blockquote>\n<p>I wonder if this might also be relevant for scenarios where <code>wasmtime compile</code> is used, and the resulting <code>.cwasm</code> file deployed to other machines. While it seems highly advisable to ensure those deployment scenarios involve pretty tight control over the target configuration, it still seems like there might be value in enabling the <code>.cwasm</code> file to run on a broader range of hardware.</p>\n</blockquote>\n<p>While I was writing the proposal, my assumption was that even if Wasmtime compiled a Wasm module ahead-of-time, the machine on which the generated code executed would usually have the same (or better) capabilities than those enabled during compilation. How important is the opposite use case? @cfallin also <a href=\"https://github.com/bytecodealliance/rfcs/pull/17/files#r736731923\">expressed</a> some reservations about the overhead of the additional instructions, so machines without PAuth support would probably rather avoid them.</p>\n<p>Also, this discussion might be relevant in the context of forward-edge CFI using Intel CET, I believe.</p>\n</blockquote>",
        "id": 265187940,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1639675042
    },
    {
        "content": "<p>akirilov-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-996017063\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<p>@tschneidereit</p>\n<blockquote>\n<p>I wonder if this might also be relevant for scenarios where <code>wasmtime compile</code> is used, and the resulting <code>.cwasm</code> file deployed to other machines. While it seems highly advisable to ensure those deployment scenarios involve pretty tight control over the target configuration, it still seems like there might be value in enabling the <code>.cwasm</code> file to run on a broader range of hardware.</p>\n</blockquote>\n<p>While I was writing the proposal, my assumption was that even if Wasmtime compiled a Wasm module ahead-of-time, the machine on which the generated code executed would usually have the same (or better) capabilities than those enabled during compilation. How important is the opposite use case? @cfallin also <a href=\"https://github.com/bytecodealliance/rfcs/pull/17/files#r736731923\">expressed</a> some reservations about the overhead of the additional instructions, so machines without PAuth support would probably rather avoid them.</p>\n<p>Also, this discussion might be relevant in the context of forward-edge CFI using Intel CET, I believe.</p>\n<p><strong>P.S.</strong> What we have been talking about so far is essentially a forward compatibility issue with PAuth, but after experimenting with BTI I have realized that there is another, backward compatibility problem - imagine that a Wasm module is compiled ahead-of-time without any BTI support, so the generated code will not contain any BTI instructions, and then a machine that does support BTI tries to execute the code. The latter will mark the executable memory pages as containing BTI instructions, which will cause crashes because all indirect branches will fault due to the missing instructions. The solution to this issue for static compilers involves <a href=\"https://github.com/ARM-software/abi-aa/blob/2021Q3/aaelf64.rst#process-gnu-property-aarch64-feature-1-bti\">a couple of ELF extensions</a>, so we could use something similar for the <code>.cwasm</code> files generated by Wasmtime. Alternatively, if we agree that we do not support the case in which the hardware capabilities in the compilation environment differ from those in the execution environment, then we would not need to do anything special.</p>\n</blockquote>",
        "id": 265194475,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1639677723
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1017696659\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<p>During the last Cranelift project meeting @alexcrichton mentioned that Wasmtime would error out if it tried to load an AOT compiled module that was built with different settings than the ones used by the current environment, which means that supporting the <code>NOP</code> versions of the instructions is not that important, at least for the Wasmtime use case.</p>\n</blockquote>",
        "id": 268720390,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1642696733
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1061984533\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<p>I have updated the proposal text to align it with the equivalent work on the Rust compiler; also, the changes should address the comments from the discussion above.</p>\n<p>There is a suggestion that @abrown made elsewhere - since BTI and the <code>ENDBR</code> instruction introduced by Intel CET are quite similar, it makes sense to consider a generic setting to control their usage. Of course, the question is what would targets that don't have special hardware support for an equivalent mechanism (such as s390x, I believe) do - one option is to just return an error if the generic setting is enabled, while another is to implement a software-only protection such as the one I discuss briefly in the proposal text. Currently, I have chosen to keep the setting controlling BTI usage to be AArch64-specific.</p>\n</blockquote>",
        "id": 274568654,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1646758084
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1090141157\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<h1>Motion to finalize with a disposition to merge</h1>\n<p>As discussed during <a href=\"https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/meetings/cranelift/2022/cranelift-04-04.md\">the last Cranelift biweekly meeting</a>, I believe that all the comments on the text so far have been addressed, and there hasn't been any strong opposition, so I'm proposing that we merge this RFC.</p>\n<p>Thanks everyone for the discussion and the feedback!</p>\n<h2>Stakeholders sign-off</h2>\n<h3>Arm</h3>\n<ul>\n<li>[x] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h3>DFINITY</h3>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h3>Embark Studios</h3>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h3>Fastly</h3>\n<ul>\n<li>[ ] @acfoltzer</li>\n<li>[ ] @alexcrichton</li>\n<li>[ ] @aturon</li>\n<li>[ ] @cfallin</li>\n<li>[ ] @cratelyn</li>\n<li>[ ] @fitzgen</li>\n<li>[ ] @iximeow</li>\n<li>[ ] @pchickey</li>\n<li>[ ] @peterhuene</li>\n<li>[ ] @sunfishcode</li>\n<li>[ ] @tschneidereit</li>\n</ul>\n<h3>Fermyon</h3>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h3>Google / Envoy</h3>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h3>IBM</h3>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h3>Intel</h3>\n<ul>\n<li>[ ] @abrown</li>\n<li>[ ] @jlb6740</li>\n<li>[ ] @mingqiusun</li>\n</ul>\n<h3>Microsoft</h3>\n<ul>\n<li>[ ] @squillace</li>\n</ul>\n<h3>Mozilla</h3>\n<ul>\n<li>[ ] @julian-seward1</li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h3>wasmCloud</h3>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h3>Unaffiliated</h3>\n<ul>\n<li>[ ] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 278007222,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1649243145
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1090141157\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<h1>Motion to finalize with a disposition to merge</h1>\n<p>As discussed during <a href=\"https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/meetings/cranelift/2022/cranelift-04-04.md\">the last Cranelift biweekly meeting</a>, I believe that all the comments on the text so far have been addressed, and there hasn't been any strong opposition, so I'm proposing that we merge this RFC.</p>\n<p>Thanks everyone for the discussion and the feedback!</p>\n<h2>Stakeholders sign-off</h2>\n<h3>Arm</h3>\n<ul>\n<li>[x] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h3>DFINITY</h3>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h3>Embark Studios</h3>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h3>Fastly</h3>\n<ul>\n<li>[ ] @acfoltzer</li>\n<li>[ ] @alexcrichton</li>\n<li>[ ] @aturon</li>\n<li>[x] @cfallin</li>\n<li>[ ] @cratelyn</li>\n<li>[ ] @fitzgen</li>\n<li>[ ] @iximeow</li>\n<li>[ ] @pchickey</li>\n<li>[ ] @peterhuene</li>\n<li>[ ] @sunfishcode</li>\n<li>[ ] @tschneidereit</li>\n</ul>\n<h3>Fermyon</h3>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h3>Google / Envoy</h3>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h3>IBM</h3>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h3>Intel</h3>\n<ul>\n<li>[ ] @abrown</li>\n<li>[ ] @jlb6740</li>\n<li>[ ] @mingqiusun</li>\n</ul>\n<h3>Microsoft</h3>\n<ul>\n<li>[ ] @squillace</li>\n</ul>\n<h3>Mozilla</h3>\n<ul>\n<li>[ ] @julian-seward1</li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h3>wasmCloud</h3>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h3>Unaffiliated</h3>\n<ul>\n<li>[ ] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 278189630,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1649348391
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1090141157\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<h1>Motion to finalize with a disposition to merge</h1>\n<p>As discussed during <a href=\"https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/meetings/cranelift/2022/cranelift-04-04.md\">the last Cranelift biweekly meeting</a>, I believe that all the comments on the text so far have been addressed, and there hasn't been any strong opposition, so I'm proposing that we merge this RFC.</p>\n<p>Thanks everyone for the discussion and the feedback!</p>\n<h2>Stakeholders sign-off</h2>\n<h3>Arm</h3>\n<ul>\n<li>[x] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h3>DFINITY</h3>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h3>Embark Studios</h3>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h3>Fastly</h3>\n<ul>\n<li>[ ] @acfoltzer</li>\n<li>[ ] @alexcrichton</li>\n<li>[ ] @aturon</li>\n<li>[x] @cfallin</li>\n<li>[ ] @cratelyn</li>\n<li>[ ] @fitzgen</li>\n<li>[ ] @iximeow</li>\n<li>[ ] @pchickey</li>\n<li>[ ] @peterhuene</li>\n<li>[ ] @sunfishcode</li>\n<li>[ ] @tschneidereit</li>\n</ul>\n<h3>Fermyon</h3>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h3>Google / Envoy</h3>\n<ul>\n<li>[ ] @PiotrSikora</li>\n</ul>\n<h3>IBM</h3>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h3>Intel</h3>\n<ul>\n<li>[ ] @abrown</li>\n<li>[ ] @jlb6740</li>\n<li>[ ] @mingqiusun</li>\n</ul>\n<h3>Microsoft</h3>\n<ul>\n<li>[ ] @squillace</li>\n</ul>\n<h3>Mozilla</h3>\n<ul>\n<li>[ ] @julian-seward1</li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h3>wasmCloud</h3>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h3>Unaffiliated</h3>\n<ul>\n<li>[x] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 278189648,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1649348398
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1090141157\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<h1>Motion to finalize with a disposition to merge</h1>\n<p>As discussed during <a href=\"https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/meetings/cranelift/2022/cranelift-04-04.md\">the last Cranelift biweekly meeting</a>, I believe that all the comments on the text so far have been addressed, and there hasn't been any strong opposition, so I'm proposing that we merge this RFC.</p>\n<p>Thanks everyone for the discussion and the feedback!</p>\n<h2>Stakeholders sign-off</h2>\n<h3>Arm</h3>\n<ul>\n<li>[x] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h3>DFINITY</h3>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h3>Embark Studios</h3>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h3>Fastly</h3>\n<ul>\n<li>[ ] @acfoltzer</li>\n<li>[ ] @alexcrichton</li>\n<li>[ ] @aturon</li>\n<li>[x] @cfallin</li>\n<li>[ ] @cratelyn</li>\n<li>[ ] @fitzgen</li>\n<li>[ ] @iximeow</li>\n<li>[ ] @pchickey</li>\n<li>[ ] @peterhuene</li>\n<li>[ ] @sunfishcode</li>\n<li>[ ] @tschneidereit</li>\n</ul>\n<h3>Fermyon</h3>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h3>Google / Envoy</h3>\n<ul>\n<li>[x] @PiotrSikora</li>\n</ul>\n<h3>IBM</h3>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h3>Intel</h3>\n<ul>\n<li>[ ] @abrown</li>\n<li>[ ] @jlb6740</li>\n<li>[ ] @mingqiusun</li>\n</ul>\n<h3>Microsoft</h3>\n<ul>\n<li>[ ] @squillace</li>\n</ul>\n<h3>Mozilla</h3>\n<ul>\n<li>[ ] @julian-seward1</li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h3>wasmCloud</h3>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h3>Unaffiliated</h3>\n<ul>\n<li>[x] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 278189702,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1649348404
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1092211980\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<h1>Entering Final Call Period</h1>\n<p>Now that we have sign-offs from multiple separate groups, as per <a href=\"https://github.com/bytecodealliance/rfcs/blob/d3fd6aecf83de2b7b809bf6ce649327747139194/accepted/rfc-process.md#making-a-decision-merge-or-close\">the process</a> this RFC will move into a final comment period (FCP).</p>\n<p>The FCP will end on Monday, April 18.</p>\n</blockquote>",
        "id": 278228276,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1649366581
    },
    {
        "content": "<p>akirilov-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1092211980\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<h1>Entering Final Comment Period</h1>\n<p>Now that we have sign-offs from multiple separate groups, as per <a href=\"https://github.com/bytecodealliance/rfcs/blob/d3fd6aecf83de2b7b809bf6ce649327747139194/accepted/rfc-process.md#making-a-decision-merge-or-close\">the process</a> this RFC will move into a final comment period (FCP).</p>\n<p>The FCP will end on Monday, April 18.</p>\n</blockquote>",
        "id": 278228541,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1649366746
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1090141157\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<h1>Motion to finalize with a disposition to merge</h1>\n<p>As discussed during <a href=\"https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/meetings/cranelift/2022/cranelift-04-04.md\">the last Cranelift biweekly meeting</a>, I believe that all the comments on the text so far have been addressed, and there hasn't been any strong opposition, so I'm proposing that we merge this RFC.</p>\n<p>Thanks everyone for the discussion and the feedback!</p>\n<h2>Stakeholders sign-off</h2>\n<h3>Arm</h3>\n<ul>\n<li>[x] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h3>DFINITY</h3>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h3>Embark Studios</h3>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h3>Fastly</h3>\n<ul>\n<li>[ ] @acfoltzer</li>\n<li>[ ] @alexcrichton</li>\n<li>[ ] @aturon</li>\n<li>[x] @cfallin</li>\n<li>[ ] @cratelyn</li>\n<li>[x] @fitzgen</li>\n<li>[ ] @iximeow</li>\n<li>[ ] @pchickey</li>\n<li>[ ] @peterhuene</li>\n<li>[ ] @sunfishcode</li>\n<li>[ ] @tschneidereit</li>\n</ul>\n<h3>Fermyon</h3>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[ ] @radu-matei</li>\n</ul>\n<h3>Google / Envoy</h3>\n<ul>\n<li>[x] @PiotrSikora</li>\n</ul>\n<h3>IBM</h3>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h3>Intel</h3>\n<ul>\n<li>[ ] @abrown</li>\n<li>[ ] @jlb6740</li>\n<li>[ ] @mingqiusun</li>\n</ul>\n<h3>Microsoft</h3>\n<ul>\n<li>[ ] @squillace</li>\n</ul>\n<h3>Mozilla</h3>\n<ul>\n<li>[ ] @julian-seward1</li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h3>wasmCloud</h3>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h3>Unaffiliated</h3>\n<ul>\n<li>[x] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 278582054,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1649695459
    },
    {
        "content": "<p>akirilov-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1090141157\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<h1>Motion to finalize with a disposition to merge</h1>\n<p>As discussed during <a href=\"https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/meetings/cranelift/2022/cranelift-04-04.md\">the last Cranelift biweekly meeting</a>, I believe that all the comments on the text so far have been addressed, and there hasn't been any strong opposition, so I'm proposing that we merge this RFC.</p>\n<p>Thanks everyone for the discussion and the feedback!</p>\n<h2>Stakeholders sign-off</h2>\n<h3>Arm</h3>\n<ul>\n<li>[x] @akirilov-arm</li>\n<li>[ ] @sparker-arm</li>\n</ul>\n<h3>DFINITY</h3>\n<ul>\n<li>[ ] @granstrom</li>\n</ul>\n<h3>Embark Studios</h3>\n<ul>\n<li>[ ] @bnjbvr</li>\n<li>[ ] @repi</li>\n</ul>\n<h3>Fastly</h3>\n<ul>\n<li>[ ] @acfoltzer</li>\n<li>[ ] @alexcrichton</li>\n<li>[ ] @aturon</li>\n<li>[x] @cfallin</li>\n<li>[ ] @cratelyn</li>\n<li>[x] @fitzgen</li>\n<li>[ ] @iximeow</li>\n<li>[ ] @pchickey</li>\n<li>[ ] @peterhuene</li>\n<li>[ ] @sunfishcode</li>\n<li>[ ] @tschneidereit</li>\n</ul>\n<h3>Fermyon</h3>\n<ul>\n<li>[ ] @bacongobbler</li>\n<li>[x] @radu-matei</li>\n</ul>\n<h3>Google / Envoy</h3>\n<ul>\n<li>[x] @PiotrSikora</li>\n</ul>\n<h3>IBM</h3>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n<h3>Intel</h3>\n<ul>\n<li>[ ] @abrown</li>\n<li>[ ] @jlb6740</li>\n<li>[ ] @mingqiusun</li>\n</ul>\n<h3>Microsoft</h3>\n<ul>\n<li>[ ] @squillace</li>\n</ul>\n<h3>Mozilla</h3>\n<ul>\n<li>[ ] @julian-seward1</li>\n<li>[ ] @yurydelendik</li>\n</ul>\n<h3>wasmCloud</h3>\n<ul>\n<li>[ ] @autodidaddict</li>\n</ul>\n<h3>Unaffiliated</h3>\n<ul>\n<li>[x] @bjorn3</li>\n</ul>\n</blockquote>",
        "id": 278625526,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1649716174
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/17#issuecomment-1104020816\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/17\">issue #17</a>:</p>\n<blockquote>\n<p>The FCP has ended without any objections raised and without further discussion, so it is time to merge this RFC proposal. Thanks everyone for the discussion!</p>\n</blockquote>",
        "id": 279552859,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1650466009
    }
]