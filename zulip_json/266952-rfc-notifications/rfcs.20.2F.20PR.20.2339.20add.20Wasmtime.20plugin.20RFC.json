[
    {
        "content": "<p>rvolosatovs opened <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a> from <code>rvolosatovs:wasmtime-plugins</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>Refs <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7348\">https://github.com/bytecodealliance/wasmtime/issues/7348</a></p>\n<p><a href=\"https://github.com/rvolosatovs/rfcs/blob/fa9cdc185a389a9503df246905d054d132ce97f5/accepted/wasmtime-plugins.md\">Rendered</a></p>\n</blockquote>",
        "id": 477681165,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729265516
    },
    {
        "content": "<p>programmerjake <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2422861386\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<p>i don't see a way to access a .so global variable from wasm...</p>\n</blockquote>",
        "id": 477693616,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729269770
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2422956264\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<blockquote>\n<p>i don't see a way to access a .so global variable from wasm...</p>\n</blockquote>\n<p>indeed, I did not add this functionality in the current <code>wasi-dl</code> draft, it's really just an approximation sufficient for a very basic PoC</p>\n<p>Does <a href=\"https://github.com/rvolosatovs/wasi-dl/pull/1\">https://github.com/rvolosatovs/wasi-dl/pull/1</a> address your concern? <code>alloc</code> can be interpreted as any <code>ffi-type</code> or even a function.</p>\n<p>Perhaps <code>resource symbol</code> is redundant altogether and lookups should just return <code>alloc</code> resources, which can be interpreted as functions</p>\n</blockquote>",
        "id": 477702787,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729273609
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2422956264\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<blockquote>\n<p>i don't see a way to access a .so global variable from wasm...</p>\n</blockquote>\n<p>indeed, I did not add this functionality in the current <code>wasi-dl</code> draft, it's really just an approximation sufficient for a very basic PoC</p>\n<p>Does <a href=\"https://github.com/rvolosatovs/wasi-dl/pull/1\">https://github.com/rvolosatovs/wasi-dl/pull/1</a> address your concern? <code>alloc</code> can be interpreted as any <code>ffi-type</code> or even a function.</p>\n<p>Perhaps <code>resource symbol</code> is redundant altogether and lookups should just return <code>alloc</code> resources, which can be interpreted as functions</p>\n<p>Edit: added <a href=\"https://github.com/rvolosatovs/wasi-dl/pull/1/commits/30ea77f0d5679f8382603890408c6fef0bc4713b\">https://github.com/rvolosatovs/wasi-dl/pull/1/commits/30ea77f0d5679f8382603890408c6fef0bc4713b</a></p>\n</blockquote>",
        "id": 477703372,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729273831
    },
    {
        "content": "<p>rvolosatovs updated <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>.</p>",
        "id": 477703673,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729273964
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2422956264\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<blockquote>\n<p>i don't see a way to access a .so global variable from wasm...</p>\n</blockquote>\n<p>indeed, I did not add this functionality in the current <code>wasi-dl</code> draft, it's really just an approximation sufficient for a very basic PoC</p>\n<p>Does <a href=\"https://github.com/rvolosatovs/wasi-dl/pull/1\">https://github.com/rvolosatovs/wasi-dl/pull/1</a> address your concern? <code>alloc</code> can be interpreted as any <code>ffi-type</code> or even a function.</p>\n<p>Perhaps <code>resource symbol</code> is redundant altogether and lookups should just return <code>alloc</code> resources, which can be interpreted as functions</p>\n<p>Edit: added <a href=\"https://github.com/rvolosatovs/wasi-dl/pull/1/commits/30ea77f0d5679f8382603890408c6fef0bc4713b\">https://github.com/rvolosatovs/wasi-dl/pull/1/commits/30ea77f0d5679f8382603890408c6fef0bc4713b</a><br>\nEdit 2: updated PR with <a href=\"https://github.com/bytecodealliance/rfcs/pull/39/commits/b48bdaa743642403ab3ac771495bd882f571d88b\">https://github.com/bytecodealliance/rfcs/pull/39/commits/b48bdaa743642403ab3ac771495bd882f571d88b</a></p>\n</blockquote>",
        "id": 477703727,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729273989
    },
    {
        "content": "<p>programmerjake <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2422987920\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<blockquote>\n<p>Does <a href=\"https://github.com/rvolosatovs/wasi-dl/pull/1\">rvolosatovs/wasi-dl#1</a> address your concern?</p>\n</blockquote>\n<p>yes!</p>\n</blockquote>",
        "id": 477706004,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729274886
    },
    {
        "content": "<p>rvolosatovs updated <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>.</p>",
        "id": 477718020,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729279965
    },
    {
        "content": "<p>rvolosatovs edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<p>Refs <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7348\">https://github.com/bytecodealliance/wasmtime/issues/7348</a></p>\n<p><a href=\"https://github.com/rvolosatovs/rfcs/blob/wasmtime-plugins/accepted/wasmtime-plugins.md\">Rendered</a></p>\n</blockquote>",
        "id": 477718259,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729280055
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2423117881\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<p>Did a small update to ensure the symbol lookups are typed <a href=\"https://github.com/bytecodealliance/rfcs/pull/39/commits/b9ae4c912db5d96956c1b57a2e74696a55db6b62\">https://github.com/bytecodealliance/rfcs/pull/39/commits/b9ae4c912db5d96956c1b57a2e74696a55db6b62</a></p>\n</blockquote>",
        "id": 477718677,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729280248
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2427128784\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<blockquote>\n<p>Such interface is <em>unsafe</em> and it must be used with extreme care, however that is no different from any other host plugin, which would be loaded via <code>dlopen</code>. </p>\n</blockquote>\n<p>There are two kinds of unsafe relevant here. One is whether the plugin code is unsafe, and I agree that this is basically the same with any host plugin system we'd design here. The other is whether Wasm code <em>using</em> the plugin code is unsafe. </p>\n<p>The libffi-style approach in this proposal looks like it means that we'd additionally have to treat the Wasm that calls the code as unsafe by default, and while there are potential ways to make it safe, they aren't described here.</p>\n<p>Also, the libffi-style approach in this proposal looks like it would mean that the Wasm would not be portable, in general, because libffi doesn't encapsulate all C ABI details. What is <code>off_t</code> a typedef for? What is the value of <code>ENOENT</code>? And so on.</p>\n<blockquote>\n<p>[wasi-dl]-based approach also provides greater security, since the implementation of [wasi-dl] may restrict the set of libraries allowed to be loaded and potentially define the exact signatures for symbols defined in them.</p>\n</blockquote>\n<p>This proposal does not currently describe how this would work. And, signatures alone would not be sufficient, because libffi-style bindings also include <a href=\"https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L56\">raw pointers</a>.</p>\n<p>Perhaps it would be possible to design an interface description language sophisticated enough to describe these interfaces, including signatures, lifetime information, synchronization information, and perhaps also resource lifetimes (eg. open files that need to be explicitly closed and not used thereafter), and perhaps eventually even a way to describe C <code>union</code>s, or some safe variant-like subset of them. If this rfc implies the design of a new interface description language, it'd be good to say more about what that looks like. </p>\n<blockquote>\n<p>As an alternative to exposing <a href=\"https://github.com/rvolosatovs/wasi-dl\">wasi-dl</a> interface to (plugin) components, we could use the dynamic libraries themselves as the host plugins. For that we would need to carefully design a set of conventions specific to wasmtime for such plugins to be able to define their exports and expose them to components.</p>\n</blockquote>\n<blockquote>\n<p>Such an approach would require custom-built dynamic libraries for plugins, if an existing library was desired to be used, an \"adapter\" library would need to be built, which would in turn dynamically-load that library.</p>\n</blockquote>\n<p>It looks like this proposal would also usually want \"adapter\" libraries too, or at least adapter layers, because I don't expect we'll want normal Wasm code talking directly to these low-level libffi-style APIs, for ergonomics, language-independence, portability, and potential security reasons. And these adapters are going to be tedious to write and maintain, because they need to be written for each source language that needs them, and they'll have a lot of repetitive low-level code. I imagine we'd pretty quickly find ourselves wanting bindings generators for this task.</p>\n<p>And if we're going to design a language-independent sandboxable interface description language with tooling around it for generating bindings, we should think carefully about whether or not we already have one, and what relationships we want <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>.</p>\n</blockquote>",
        "id": 478100152,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1729527322
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#pullrequestreview-2408672327\">PR review</a>:</p>\n<blockquote>\n<p>Thanks for writing up this RFC!</p>\n<p>I agree that a plugin system geared towards allowing hosts to define and expose new capabilities to Wasm guests that Wasmtime has no builtin knowledge of is very valuable.</p>\n<p>Unfortunately, I think a missing constraint is that we fundamentally cannot trust Wasm guests, so we can't just expose <code>dlopen</code>/<code>dlsym</code> and raw FFI types to them. Therefore, I don't think the solution proposed here is something we can pursue. More details inline below.</p>\n<p>That said, I also sketch (very roughly) an alternative approach that should address the same motivations but which avoids giving untrusted Wasm guests raw <code>dlopen</code> powers.</p>\n</blockquote>",
        "id": 479947872,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730403394
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#discussion_r1824927718\">PR review comment</a>:</p>\n<blockquote>\n<p>I guess the answer to the previous question is \"yes\" then.</p>\n<p>I see @sunfishcode's comments now, and I agree with the gist of his points.</p>\n<p>There is a difference between whether</p>\n<ol>\n<li>the plugin internally is using <code>unsafe</code> but exposing a safe interface, and</li>\n<li>the plugin's interface is itself <code>unsafe</code>.</li>\n</ol>\n<p>With (1) the (untrusted and potentially malicious) Wasm guest cannot trigger any memory safety, modulo implementation bugs in the plugin itself.</p>\n<p>With (2) the (untrusted and potentially malicious) Wasm guest can trivially trigger memory unsafety. That is, (2) is handing security vulnerabilities to Wasm guests <em>by design</em>.</p>\n<p>So (2) is a complete non-starter; it is contradictory to Wasmtime's (and the BA's) mission and values.</p>\n<p>And -- correct me if I'm wrong! -- this RFC seems to be proposing (2) so, unless I am misunderstanding the proposal, this is not an approach we should consider or pursue any further.</p>\n</blockquote>",
        "id": 479947874,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730403394
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#discussion_r1825062649\">PR review comment</a>:</p>\n<blockquote>\n<p>To be more constructive, I would suggest an alternative approach that maintains a safe interface to Wasm, something like:</p>\n<ul>\n<li>There is some well-known symbol that plugin <code>.so</code>s should export, describing their WIT interface (maybe literally just a <code>static WIT_INTERFACE: &amp;'static str = \"...\"</code> or alternatively the binary encoding of the same thing).</li>\n<li>Wasmtime loads a <code>plugin.so</code> and reads its WIT interface</li>\n<li>Wasmtime <code>dlsym</code>s the functions described by the WIT interface</li>\n<li>Wasmtime adds functions for that WIT interface to a <code>Linker</code>, these functions<ul>\n<li>translates Wasm / canonical ABI arguments into the equivalent in some sort of native ABI</li>\n<li>call their corresponding <code>dlsym</code>ed functions from <code>plugin.so</code></li>\n<li>translate the native ABI's result back into Wasm / canonical ABI</li>\n</ul>\n</li>\n</ul>\n<p>In the above sketch, the <code>plugin.so</code> is trusted, but the Wasm is not. Any unsafety can only come from bugs in the <code>plugin.so</code> (either from its internal implementation or if its functions' types don't match the WIT interface it claims). Notably, unsafety cannot originate from within (untrusted and potentially malicious) Wasm guests, no matter what garbage values they indirectly pass to <code>plugin.so</code>.</p>\n<p>The tricky parts here will be:</p>\n<ul>\n<li>What is the native ABI? Can we reuse the canonical ABI or a variant of it? I could imagine a <code>bindgen</code>-y proc macro that does some variant of the canonical ABI for plugins with statically-known interfaces, but what about dynamic interfaces (i.e. the common case for the <code>wasmtime</code> cli, rather than a <code>wasmtime</code> crate embedding that happens to use plugins of a certain shape)? What can we do to avoid arg/result translation overheads?</li>\n<li>A <code>plugin.so</code> may want some per-<code>Store</code> state, for example if <code>wasi-sockets</code> was implemented as a plugin, it would want any open sockets to be attached to the <code>Store</code>. How do we let <code>plugin.so</code> create that per-<code>Store</code> state? Where do we keep it? How do we pass it back to <code>plugin.so</code> on each call? How do we let <code>plugin.so</code> destroy it when we drop the store?</li>\n<li>Finally, it isn't clear to me whether this RFC proposes that <code>plugin.so</code>s are forwards compatible with new <code>wasmtime</code> versions (i.e. new Wasmtime releases are backwards compatible with old <code>plugin.so</code>s) or not. If so, then the ABI concerns described above are doubly important and we need to make sure they remain extensible for future additions and changes, which will involve a lot of subtleties.</li>\n</ul>\n</blockquote>",
        "id": 479947876,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730403395
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#discussion_r1824907325\">PR review comment</a>:</p>\n<blockquote>\n<p>Would this result in memory unsafety if the Wasm (which is untrusted, and potentially malicious) passes the wrong number or type of arguments and returns?</p>\n<p>Or is it expected that Wasmtime will somehow dynamically check these calls?</p>\n<p>Similar question for declaring FFI struct types and their fields.</p>\n</blockquote>",
        "id": 479947877,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730403395
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2451778905\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<p>Thanks for the feedback @sunfishcode @fitzgen!</p>\n<p>In general I feel that perhaps I misjudged the expected level of detail for RFCs in this repository, this RFC currently is very much a high-level idea/direction, as opposed to directly-implementable design document, which seems to what people are searching for here.</p>\n<p>First, let's agree on some terms:</p>\n<p>In this RFC by <em>component composition</em> I mostly refer to <em>function-style</em> composition, and <em>not</em> component composition as defined at <a href=\"https://component-model.bytecodealliance.org/creating-and-consuming/composing.html#what-is-composition\">https://component-model.bytecodealliance.org/creating-and-consuming/composing.html#what-is-composition</a><br>\nFor example, <a href=\"https://github.com/bytecodealliance/WASI-Virt\"><code>wasi-virt</code></a> can mostly fulfill the composition as would be required here.</p>\n<p>More formally, let's assume that components are morphisms (functors) that map a set of interfaces (imports) to another set of interfaces (exports).</p>\n<p>Their composition is depicted here: ![composition](<a href=\"https://upload.wikimedia.org/wikipedia/commons/e/ef/Commutative_diagram_for_morphism.svg\">https://upload.wikimedia.org/wikipedia/commons/e/ef/Commutative_diagram_for_morphism.svg</a>), taken directly from <a href=\"https://en.wikipedia.org/wiki/Category_theory\">Category theory</a> Wikipedia page.</p>\n<p>Here's an example in context of this RFC:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>// Trusted Wasm targets this world\nworld plugin {\n    // These two interfaces are provided by the host:\n    import wasi:sockets/tcp;\n    import wasi:dl/dl;\n\n    // These two interfaces are provided to the guest:\n    export wasi:sockets/tcp;\n    export wasi:keyvalue/store;\n}\n\n// Untrusted Wasm targets this world\nworld guest {\n    // These two interfaces are either directly provided by the plugin component or passed through to the host *staticaly* by the composition tool:\n    import wasi:sockets/tcp;\n    import wasi:keyvalue/store;\n\n    export wasi:http/incoming-handler;\n\n    // NOTE: This import would *not* be satisfied:\n    // import wasi:dl/dl;\n}\n\nworld composed {\n    import wasi:sockets/tcp;\n    import wasi:dl/dl;\n    export wasi:http/incoming-handler;\n}\n</code></pre></div>\n<p>@fitzgen you seem to imply that <em>all</em> Wasm is implicitly untrusted.</p>\n<p>I'm not sure I agree with that statement and the assumption I'm operating upon is that whether a trusted piece of code is compiled into a native application/library or a Wasm component should not change the \"trustworthiness\" of the produced artifact. That's a key assumption on which this RFC is built.</p>\n<p>Is there something specific about Wasm components I'm not aware of, that would make them inherently untrusted?</p>\n<p>In <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#discussion_r1825062649\">https://github.com/bytecodealliance/rfcs/pull/39#discussion_r1825062649</a> you've outlined a way how a plugin could be loaded by Wasmtime:</p>\n<blockquote>\n<ul>\n<li>\n<p>There is some well-known symbol that plugin <code>.so</code>s should export, describing their WIT interface (maybe literally just a <code>static WIT_INTERFACE: &amp;'static str = \"...\"</code> or alternatively the binary encoding of the same thing).</p>\n</li>\n<li>\n<p>Wasmtime loads a <code>plugin.so</code> and reads its WIT interface</p>\n</li>\n<li>\n<p>Wasmtime <code>dlsym</code>s the functions described by the WIT interface</p>\n</li>\n<li>\n<p>Wasmtime adds functions for that WIT interface to a <code>Linker</code>, these functions</p>\n<ul>\n<li>translates Wasm / canonical ABI arguments into the equivalent in some sort of native ABI</li>\n<li>call their corresponding <code>dlsym</code>ed functions from <code>plugin.so</code></li>\n<li>translate the native ABI's result back into Wasm / canonical ABI</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>Note, that adding functions to the <code>Linker</code> using <code>dlopen</code> and instantiating the (untrusted) Wasm component using it produces a runtime object, which is effectively the composition as I defined above, except it happens at <em>runtime</em>.</p>\n<p>In the context of this RFC, the plugin could operate exactly like you've outlined in <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#discussion_r1825062649\">https://github.com/bytecodealliance/rfcs/pull/39#discussion_r1825062649</a>, except wasmtime CLI would load <code>plugin.wasm</code> as opposed to <code>plugin.so</code>.</p>\n<p>Let's consider an example with a shared library plugin (this is <em>not</em> an API suggestion, just a quick example sketch):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">serve</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">plugin</span><span class=\"w\"> </span><span class=\"n\">plugin</span><span class=\"p\">.</span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">untrusted</span><span class=\"p\">.</span><span class=\"n\">wasm</span>\n</code></pre></div>\n<p><code>plugin.so</code> would be operating directly as part of runtime's process with no sandboxing whatsoever, it has full, unconstrained access to the OS and runtime process memory.</p>\n<p>An example usage with a Wasm component plugin could look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">serve</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">plugin</span><span class=\"w\"> </span><span class=\"n\">plugin</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">tcp</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">dl</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">untrusted</span><span class=\"p\">.</span><span class=\"n\">wasm</span>\n</code></pre></div>\n<ul>\n<li><code>plugin.wasm</code> is operating in different \"trust mode\", from <code>untrusted.wasm</code>, but still <em>sandboxed</em>.</li>\n<li>\n<p>The CLI user explicitly allows <code>plugin.wasm</code> to use <code>tcp</code> and <code>wasi-dl</code>, it has no access to anything else.<br>\n    - <code>wasi-dl</code> access could be scoped, e.g. (again, just a quick sketch):</p>\n<p><code>\n  wasmtime serve --plugin plugin.wasm -P tcp=y -P dl=libm.so:libm.h -P dl=sqlite3.so:sqlite3.h untrusted.wasm\n  </code></p>\n<p>With an API like this the plugin could only ever load <code>libm.so</code> or <code>sqlite3.so</code> - the associated header files could be used to verify <code>wasi-dl</code> calls and would, given the shared library and associated header file correctness, guarantee memory safety.<br>\n  Note, that loading C headers is probably a lot of work and I'm not suggesting doing that, rather just pointing out that there <em>is</em> a way to make such interface safe.</p>\n</li>\n<li>\n<p><code>untrusted.wasm</code> <em>does not</em> inherit <code>plugin.wasm</code> imports - <code>untrusted.wasm</code> in this scenario <em>only</em> has access to interfaces exported and implemented by <code>plugin.wasm</code>, nothing else.</p>\n</li>\n</ul>\n<p>In both cases, one way or another, <code>wasmtime</code> would need to produce a \"runtime composition\" of a plugin and the guest component.</p>\n<p>Arguably, the Wasm plugin option is <em>safer</em>, since the runtime can control what libraries, symbols and their signatures can the plugin access.</p>\n<p>In this RFC I've decided to start with a simple approach and give the <code>wasmtime</code> CLI user more control and produce such composition ahead-of-time, drasticaly reducing the scope for this feature and improving performance.</p>\n<p>If (trusted) <code>plugin.wasm</code> (with optional <code>wasi-dl</code> access) was run in a separate sandbox, would that address your concerns @fitzgen?</p>\n<blockquote>\n<p>There are two kinds of unsafe relevant here. One is whether the plugin code is unsafe, and I agree that this is basically the same with any host plugin system we'd design here. The other is whether Wasm code _using_ the plugin code is unsafe.</p>\n<p>The libffi-style approach in this proposal looks like it means that we'd additionally have to treat the Wasm that calls the code as unsafe by default, and while there are potential ways to make it safe, they aren't described here.</p>\n</blockquote>\n<p>From perspective of memory safety purely, if <code>wasmtime</code> loaded <code>plugin.so</code>, which exported <code>wasi:keyvalue/store</code>, each <code>wasi:keyvalue/store</code> interface call in the guest would be unsafe.</p>\n<p>Whether we trust the plugin code or not, guest code directly or indirectly invoking a symbol loaded from a shared object will always be potentially memory unsafe.</p>\n<p>Like I mentioned above, the runtime could limit <code>wasi-dl</code> access and potentially made aware of the symbols exported by the libraries (or even statically link to libraries at compilation time and expose them via <code>wasi-dl</code> abstraction).</p>\n<p>Effectively, <code>wasi-dl</code> could be turned into a shared object <em>introspection</em> interface, which would be type-safe and could even verify contract constraints not directly expressable by C type system.</p>\n<p>One potential strategy could be using <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Binary.md#-value-definitions\">value definitions</a> or just functions (since recursive types are not currently allowed) to either process a C header file ahead-of-time or somehow else (e.g. manually) produce something roughly similar to:</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"p\">(</span><span class=\"err\">component</span>\n  <span class=\"p\">(</span><span class=\"k\">import</span> <span class=\"s2\">\"wasi:dl/ffi\"</span> <span class=\"p\">(</span><span class=\"err\">instance</span>\n     <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"primitive-type\"</span> <span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"nv\">$primitive_type</span> <span class=\"p\">(</span><span class=\"err\">enum</span>\n        <span class=\"s2\">\"c-char\"</span>\n        <span class=\"s2\">\"uint64-t\"</span>\n        <span class=\"c1\">;; etc..</span>\n     <span class=\"p\">)))</span>\n     <span class=\"c1\">;; etc...</span>\n  <span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"k\">import</span> <span class=\"s2\">\"wasi:dl/dll\"</span> <span class=\"p\">(</span><span class=\"err\">instance</span>\n     <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"function\"</span> <span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"nv\">$function</span> <span class=\"p\">(</span><span class=\"err\">sub</span> <span class=\"err\">resource</span><span class=\"p\">)))</span>\n     <span class=\"c1\">;; etc...</span>\n  <span class=\"p\">))</span>\n  <span class=\"c1\">;; using value definition</span>\n  <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"SOMECONST\"</span> <span class=\"p\">(</span><span class=\"err\">value</span> <span class=\"nv\">$primitive_type</span> <span class=\"p\">(</span><span class=\"err\">enum</span> <span class=\"s2\">\"uint64-t\"</span><span class=\"p\">))</span>\n  <span class=\"c1\">;; using a function, returns the C type of the constant</span>\n  <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"SOMECONST\"</span> <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">result</span> <span class=\"nv\">$primitive_type</span><span class=\"p\">)))</span>\n\n  <span class=\"c1\">;; returns a typed `wasi:dl/dll.function`</span>\n  <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"myfunc\"</span> <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">result</span> <span class=\"nv\">$function</span><span class=\"p\">)))</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n<blockquote>\n<ul>\n<li>\n<p>What is the native ABI? Can we reuse the canonical ABI or a variant of it? I could imagine a <code>bindgen</code>-y proc macro that does some variant of the canonical ABI for plugins with statically-known interfaces, but what about dynamic interfaces (i.e. the common case for the <code>wasmtime</code> cli, rather than a <code>wasmtime</code> crate embedding that happens to use plugins of a certain shape)? What can we do to avoid arg/result translation overheads?</p>\n</li>\n<li>\n<p>A <code>plugin.so</code> may want some per-<code>Store</code> state, for example if <code>wasi-sockets</code> was implemented as a plugin, it would want any open sockets to be attached to the <code>Store</code>. How do we let <code>plugin.so</code> create that per-<code>Store</code> state? Where do we keep it? How do we pass it back to <code>plugin.so</code> on each call? How do we let <code>plugin.so</code> destroy it when we drop the store?</p>\n</li>\n<li>\n<p>Finally, it isn't clear to me whether this RFC proposes that <code>plugin.so</code>s are forwards compatible with new <code>wasmtime</code> versions (i.e. new Wasmtime releases are backwards compatible with old <code>plugin.so</code>s) or not. If so, then the ABI concerns described above are doubly important and we need to make sure they remain extensible for future additions and changes, which will involve a lot of subtleties.</p>\n</li>\n</ul>\n</blockquote>\n<p>If the (trusted) plugin was a Wasm component, there'd be no need for any custom symbols or ABI - answers to most of these questions would be provided directly by the component model.</p>\n<blockquote>\n<p>Perhaps it would be possible to design an interface description language sophisticated enough to describe these interfaces, including signatures, lifetime information<br>\n[message truncated]</p>\n</blockquote>\n</blockquote>",
        "id": 480042171,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730463293
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2451819543\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<p>I think having <a href=\"http://adapter.so\">adapter.so</a> directly provide the wasm component interface rather than having to use an intermediate plugin.wasm is safer, faster and easier to use for the end user.</p>\n<p>Plugin.wasm is effectively unsandboxed as any mistake in it's use of wasi-dl would cause UB. It is a lot easier to directly define a safe wasm component interface in <a href=\"http://adapter.so\">adapter.so</a> than to export an unsafe C api and then separately consume this C api in plugin.wasm and hope that you didn't accidentally cause an ABI mismatch (as soon as you use any non-fixed size integer type (or an integer type larger than the register size) or you use a struct type or enum in your C api, it becomes non-trivial to match the ABI unless you are the C compiler that compiled <a href=\"http://adapter.so\">adapter.so</a>. And if <a href=\"http://adapter.so\">adapter.so</a> is written in Rust, avoiding a separate plugin.wasm may enable the plugin writer to entirely avoid unsafe code.</p>\n<p>Having the intermediate plugin.wasm also requires you to copy all data twice. Once from <a href=\"http://adapter.so\">adapter.so</a> to plugin.wasm and once from plugin.wasm to the wasm module that uses the plugin. If <a href=\"http://adapter.so\">adapter.so</a> directly provides a wasm component interface, it only needs to be copied once.</p>\n<p>And finally it is easier for the end user if only <a href=\"http://adapter.so\">adapter.so</a> exists. This way there can't be a version mismatch between <a href=\"http://adapter.so\">adapter.so</a> and plugin.wasm (which will likely cause UB) and you only need to copy a single file around to use the plugin.</p>\n</blockquote>",
        "id": 480046199,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730465310
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2451893527\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<blockquote>\n<p>Plugin.wasm is effectively unsandboxed as any mistake in it's use of wasi-dl would cause UB. It is a lot easier to directly define a safe wasm component interface in <a href=\"http://adapter.so\">adapter.so</a> than to export an unsafe C api and then separately consume this C api in plugin.wasm and hope that you didn't accidentally cause an ABI mismatch (as soon as you use any non-fixed size integer type (or an integer type larger than the register size) or you use a struct type or enum in your C api, it becomes non-trivial to match the ABI unless you are the C compiler that compiled <a href=\"http://adapter.so\">adapter.so</a></p>\n</blockquote>\n<p>I've outlined an example approach in <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2451778905\">https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2451778905</a>, which would let prevent UB in using <code>wasi-dl</code>.<br>\nAll primitive types are read and written via resource methods in <code>wasi-dl</code> <a href=\"https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L68-L108\">https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L68-L108</a>, so a size mismatch is not possible for non-fixed size integers - the runtime knows the sizes of C primitives at compile time, and if the component would try to write 16-bit <code>char</code> using a <code>u32</code>, it would get an error from <code>set-u32</code><br>\nThe component can query the primitive sizes at runtime using <code>sizeof</code>: <a href=\"https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L124\">https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L124</a></p>\n<p>Structs are also fully supported by <code>libffi</code>: <a href=\"https://www.chiark.greenend.org.uk/doc/libffi-dev/html/Size-and-Alignment.html\">https://www.chiark.greenend.org.uk/doc/libffi-dev/html/Size-and-Alignment.html</a><br>\nComponents would read and write them using resources <a href=\"https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L88-L117\">https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L88-L117</a>, where the runtime takes care of the alignment and size.</p>\n<blockquote>\n<p>Having the intermediate plugin.wasm also requires you to copy all data twice. Once from <a href=\"http://adapter.so\">adapter.so</a> to plugin.wasm and once from plugin.wasm to the wasm module that uses the plugin. If <a href=\"http://adapter.so\">adapter.so</a> directly provides a wasm component interface, it only needs to be copied once.</p>\n</blockquote>\n<p>A <code>plugin.wasm</code> would directly read data through the pointer from the shared object. That data would then need to be copied (assuming shared refs are not allowed) into the guest component's memory.</p>\n<p>With a <code>plugin.so</code>, it depends:<br>\nIf we want <code>plugin.so</code> to directly write into runtime's memory, the only single-copy approach I see is the following:</p>\n<ul>\n<li>Runtime gives a pointer into component's memory space to the plugin</li>\n<li>Plugin writes through the pointer</li>\n</ul>\n<p>Otherwise, we'd still need two copies</p>\n</blockquote>",
        "id": 480053649,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730468520
    },
    {
        "content": "<p>rvolosatovs closed without merge <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>.</p>",
        "id": 480055062,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730469088
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2451907457\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<p>Writing an RFC for <code>dlopen</code>-based plugins was never my intention, I've originally been working on an RFC for RPC-based plugins only, but after gathering some internal feedback and building a small PoC, decided to pivot to try and produce a unified plugin interface (the Wasm-component based one), which would cover all use cases. I personally do not have a use case for the <code>dlopen</code>-based plugins - RPC-based plugins being the only use case I'm after. Basing RPC-based plugins on shared libraries is certainly a non-starter for my use case.</p>\n<p>Given that it does not appear that Wasm-based Wasmtime plugins is something people are interested in at this time, I'll take a step back and just go ahead and close this PR, instead replacing it by my original proposal: <a href=\"https://github.com/bytecodealliance/rfcs/pull/40\">https://github.com/bytecodealliance/rfcs/pull/40</a></p>\n</blockquote>",
        "id": 480055063,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730469089
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2451914185\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/39\">PR #39</a>:</p>\n<blockquote>\n<blockquote>\n<p>I've outlined an example approach in <a href=\"https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2451778905\">https://github.com/bytecodealliance/rfcs/pull/39#issuecomment-2451778905</a>, which would let prevent UB in using wasi-dl.<br>\nAll primitive types are read and written via resource methods in wasi-dl <a href=\"https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L68-L108\">https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L68-L108</a>, so a size mismatch is not possible for non-fixed size integers - the runtime knows the sizes of C primitives at compile time, and if the component would try to write 16-bit char using a u32, it would get an error from set-u32<br>\nThe component can query the primitive sizes at runtime using sizeof: <a href=\"https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L124\">https://github.com/rvolosatovs/wasi-dl/blob/6d2000d92d96b0967eb5a7ead314a765b7f596e2/wit/dl.wit#L124</a></p>\n</blockquote>\n<p>How does Wasmtime know what type signature that <a href=\"http://adapter.so\">adapter.so</a> needs?</p>\n<blockquote>\n<p>Structs are also fully supported by libffi: <a href=\"https://www.chiark.greenend.org.uk/doc/libffi-dev/html/Size-and-Alignment.html\">https://www.chiark.greenend.org.uk/doc/libffi-dev/html/Size-and-Alignment.html</a></p>\n</blockquote>\n<p>There are edge cases where even two C compilers for the same platform disagree on the right ABI. Libffi can not know which ABI to use in those cases.</p>\n<hr>\n<blockquote>\n<p>Given that it does not appear that Wasm-based Wasmtime plugins is something people are interested in at this time, I'll take a step back and just go ahead and close this PR, instead replacing it by my original proposal: <a href=\"https://github.com/bytecodealliance/rfcs/pull/40\">https://github.com/bytecodealliance/rfcs/pull/40</a></p>\n</blockquote>\n<p>I personally would still love to see dylib based plugins that directly interface with wasm interface types, but RPC based plugins are also nice. While they would almost certainly be a bit slower, they would be easier to support for other wasm engines that can't support dlopen and would be much easier to sandbox at an OS level.</p>\n</blockquote>",
        "id": 480055714,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1730469351
    }
]