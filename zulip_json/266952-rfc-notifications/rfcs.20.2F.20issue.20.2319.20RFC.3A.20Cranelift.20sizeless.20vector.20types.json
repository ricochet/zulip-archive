[
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-996619774\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>What new instructions will be introduced for creating, loading and storing such sizeless vectors?</p>\n</blockquote>",
        "id": 265279931,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1639737885
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-996646115\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>What new instructions will be introduced for creating, loading and storing such sizeless vectors?<br>\nI think we may need to add stack related instructions, since we have explicit ones, though I'm still not completely sure why. But I expect that the main changes will be encapsulated in new heap_addr and stack_addr operations. We could probably modify the existing ones, but new ones would help isolate the ambiguous semantics of the sizeless nature.</p>\n</blockquote>\n</blockquote>",
        "id": 265283648,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1639740117
    },
    {
        "content": "<p>sparker-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-996646115\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>What new instructions will be introduced for creating, loading and storing such sizeless vectors?</p>\n</blockquote>\n<p>I think we may need to add stack related instructions, since we have explicit ones, though I'm still not completely sure why. But I expect that the main changes will be encapsulated in new heap_addr and stack_addr operations. We could probably modify the existing ones, but new ones would help isolate the ambiguous semantics of the sizeless nature.</p>\n</blockquote>",
        "id": 265283692,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1639740125
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-997053960\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>One thing to note related to the stack: both stack address computation (<code>stack_addr</code>) and regalloc spilling depend on the frame layout, which we compute by knowing the size of all types. How does the prototype currently work wrt stack layout -- does it assume some maximal size? Or are the types fixed to some (implementation-defined) size at some point between the CLIF generation and lowering?</p>\n</blockquote>",
        "id": 265365787,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1639778137
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-997068138\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>cc: @penzn</p>\n</blockquote>",
        "id": 265369975,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1639780124
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-997916542\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>@cfallin I've only just started looking into stack handling, so I don't have any concrete answers for you. For the backend part, my hand wavey plan was to try and do what is done in LLVM for SVE, where fixed-size and sizeless slots are assigned in different areas, using different pointers and the runtime value of 'VL' can be used to scale offsets into sizeless areas. I've only just looked at the machinst ABI layer though, and I will continue with that this week.</p>\n<p>At an IR level, the slots would be as sizeless (minimum 128-bits, not sure about maximum) as any other sizeless value, but as I don't know the IR well, this is the main contention that I am concerned about :) From my basic understanding, it looks like it would be easiest to create sizeless-specific instructions to handle anything stack related, so that we can preserve the current semantics for fixed-size objects, and avoid having to worry about immediate offsets into a slot of unknown size. But I'm also assuming that the different slots could be freely mingled because they're just SSA values...? Please feel free to point me at any areas of the code which you think could be problematic.</p>\n<p>If the ambiguous size of objects is going to be a serious problem for us, then there is the option of forcing a lowering to a fixed size, though this could be sub-optimal for architectures like SVE when we're not functioning as a JIT.</p>\n</blockquote>",
        "id": 265560665,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640006228
    },
    {
        "content": "<p>sparker-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-997916542\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>@cfallin I've only just started looking into stack handling, so I don't have any concrete answers for you. For the backend part, my hand wavey plan was to try and do what is done in LLVM for SVE, where fixed-size and sizeless slots are assigned in different areas, using different pointers and the runtime value of 'VL' can be used to scale offsets into sizeless areas. I've only just looked at the machinst ABI layer though, and I will continue with that this week.</p>\n<p>At an IR level, the slots would be as sizeless (minimum 128-bits, not sure about maximum) as any other sizeless value. But, as I don't know the IR well, this is the main contention that I am concerned about :) From my basic understanding, it looks like it would be easiest to create sizeless-specific instructions to handle anything stack related, so that we can preserve the current semantics for fixed-size objects, and avoid having to worry about immediate offsets into a slot of unknown size. But I'm also assuming that the different slots could be freely mingled because they're just SSA values...? Please feel free to point me at any areas of the code which you think could be problematic.</p>\n<p>If the ambiguous size of objects is going to be a serious problem for us, then there is the option of forcing a lowering to a fixed size, though this could be sub-optimal for architectures like SVE when we're not functioning as a JIT.</p>\n</blockquote>",
        "id": 265560730,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640006270
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-998318763\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>@sparker-arm Thanks for the clarifications! I think that we can definitely find a way to accommodate variable-sized types; we just need to consider the problem explicitly and make sure to fix the places it breaks any assumptions :-)</p>\n<p>A quick-and-dirty way of getting a feel for that would be to make <code>ty.bits()</code> panic when called on a variable-sized type, then run whatever vector tests updated to use the sizeless vectors. I expect that the ABI code is going to be large part of that. Note that it's not just explicit user loads/stores that we have to worry about: the regalloc, for example, assumes it can spill any register (including the new sizeless-vector ones) and needs to know how large of a spillslot to allocate.</p>\n<p>Just for clarity -- I'm not actually sure I could say for certain despite being deep into this conversation! -- when exactly is the vector size made concrete? Do we ultimately compile the code while knowing the size (e.g., we decide we're compiling for microarchitecture X, and so we choose for vectors to be 512-bits wide)? Or are we actually generating code that will only know at runtime? I had been assuming the former, but your mention of computed offsets, etc., makes me think possibly it's the latter. </p>\n<p>If we ultimately know the size statically, then it's just a phase-ordering/staging problem: we might need to rework how some of the ABI code operates, but it's not fundamentally incompatible with our model. If the latter, then it sounds like it's actually <code>alloca()</code> of sorts. We know what we need to do to make this work but it's a bit tricky, especially if we're going to have lots of spillslots.</p>\n</blockquote>",
        "id": 265623470,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640039379
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-998331406\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>It determined at runtime. For arm I believe it is fixed for each cpu, while for riscv the code can ask for any length (up to a certain maximum) and then the minimum of what the user requested and the cpu supports is chosen as far as I understand. The whole point is to make executables agnostic to the vector size supported by the cpu and thus not require recompilation when a new cpu is released with bigger vectors.</p>\n</blockquote>",
        "id": 265626034,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640041178
    },
    {
        "content": "<p>penzn <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-998378436\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>Just for clarity -- I'm not actually sure I could say for certain despite being deep into this conversation! -- when exactly is the vector size made concrete? Do we ultimately compile the code while knowing the size (e.g., we decide we're compiling for microarchitecture X, and so we choose for vectors to be 512-bits wide)? Or are we actually generating code that will only know at runtime? I had been assuming the former, but your mention of computed offsets, etc., makes me think possibly it's the latter.</p>\n</blockquote>\n<p>It should be the former, in a sense that it would be known what SIMD length a given CPU supports and then the code can be generated with the right instructions, and ideally without dynamic handling when the generated code executes. \"Determined at runtime\" is from the point of view of the developer, not wasm runtime. </p>\n</blockquote>",
        "id": 265634530,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640047777
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-998558784\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>That would only work for jit compilation and not aot compilation. With aot compilation it may not be known what cpu it runs on.</p>\n</blockquote>",
        "id": 265657579,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640074135
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-998628779\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>worry about: the regalloc, for example, assumes it can spill any register (including the new sizeless-vector ones) and needs to know how large of a spillslot to allocate.</p>\n</blockquote>\n<p>Do we actually need to know the real size though? Or does it just need to understand there's some scaling factor for any register/spill slots that hold a sizeless type..? And, as we've discussed before, the new register allocator will have to accept and understand differences between the fixed and sizeless registers and how they potentially alias.</p>\n<blockquote>\n<p>when exactly is the vector size made concrete?</p>\n</blockquote>\n<blockquote>\n<p>The whole point is to make executables agnostic to the vector size supported by the cpu and thus not require recompilation when a new cpu is released with bigger vectors.</p>\n</blockquote>\n<blockquote>\n<p>it would be known what SIMD length a given CPU supports and then the code can be generated with the right instructions, and ideally without dynamic handling when the generated code executes</p>\n</blockquote>\n<p>@penzn I thought it was still a possibility that the flexible spec would support setting the length at runtime?</p>\n<p>Either way, both these options are available, and will be both be implemented. For architectures that support runtime vector lengths, we can generate agnostic code (SVE uses the 'VL' _runtime_ variable for most of this) while Neon, AVX-2 and AVX-512 will have to choose a size during codegen. I'm currently implementing SVE and Neon, in tandem, to support for these types, and my idea is, still, that we'd have a legalisation pass that can convert sizeless to fixed sizes which would enable all the SIMD compatible backends to add (basic) support with little or no effort.</p>\n</blockquote>",
        "id": 265665922,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640080063
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-998666252\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>A quick-and-dirty way of getting a feel for that would be to make ty.bits() panic when called on a variable-sized type</p>\n</blockquote>\n<p>And thanks for this @cfallin </p>\n</blockquote>",
        "id": 265670306,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640082930
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-998999682\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>&gt; </p>\n<p>Do we actually need to know the real size though? Or does it just need to understand there's some scaling factor for any register/spill slots that hold a sizeless type..? And, as we've discussed before, the new register allocator will have to accept and understand differences between the fixed and sizeless registers and how they potentially alias.</p>\n</blockquote>\n<p>Right, it can be made to work; it's just a bit of an API change that we'll need to design and coordinate. Right now both <a href=\"http://regalloc.rs\">regalloc.rs</a> and regalloc2 are built around the notion that they manage spill space (in units of slots) and can ask how many slots a given value will need. We'll need to have some sort of notion of a separate user-managed spill space for type/regclass X.</p>\n<p>Re: stack layout more generally: none of this is impossible, but it's going to need some careful design rework in the ABI code. Specifically, right now the ABI implementation is mostly shared between aarch64, x64 and s390x, and on all architectures, <code>FP</code> (<code>RBP</code>) is kept at the top of the frame, just below return address/stack args, and used to access stack args; and <code>SP</code> (<code>RSP</code>) is kept at the bottom of the frame, as required (redzone notwithstanding). All stackslots and spillslots are accessed via offsets from <code>SP</code>. </p>\n<p>If part of the frame is variable, we'll need to either start accessing the fixed part via negative offsets from <code>FP</code>, or move <code>FP</code> below the fixed part and above the variable part, or keep another base register. The third is not great (extra register pressure). The first was how my original aarch64 ABI impl worked, but we switched from negative-from-FP to positive-from-SP since the encoding is more efficient. So we're left with the second, which is I think how other compilers also handle variable frame sizes on aarch64 (?). The issue with that is that we share the generic ABI code with x64, and on x64, we have to keep <code>RBP</code> at the top of the frame in the Windows Fastcall ABI. Also relevant: there's support for omitting frame pointer setup when unneeded (in leaf functions at least); that interacts with this decision too.</p>\n<p>So we can definitely work this out, but we'll need to probably add \"modes\" to the ABI: where is FP, from which base register are (i) args, (ii) fixed slots, (iii) variable slots accessed, how unwind info is emitted correctly in all cases, etc. Lots of interacting moving parts.</p>\n<p>All of the above is needed for e.g. <code>alloca()</code> support as well, and is not unique to runtime-variable-sized types, but this may be the thing that forces the need first; so, thanks for pioneering the trail :-)</p>\n</blockquote>",
        "id": 265718591,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640111155
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-998999682\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>&gt; </p>\n<p>Do we actually need to know the real size though? Or does it just need to understand there's some scaling factor for any register/spill slots that hold a sizeless type..? And, as we've discussed before, the new register allocator will have to accept and understand differences between the fixed and sizeless registers and how they potentially alias.</p>\n</blockquote>\n<p>Right, it can be made to work; it's just a bit of an API change that we'll need to design and coordinate. Right now both <a href=\"http://regalloc.rs\">regalloc.rs</a> and regalloc2 are built around the notion that they manage spill space (in units of slots) and can ask how many slots a given value will need. We'll need to have some sort of notion of a separate user-managed spill space for type/regclass X.</p>\n<p>Re: stack layout more generally: none of this is impossible, but it's going to need some careful design rework in the ABI code. Specifically, right now the ABI implementation is mostly shared between aarch64, x64 and s390x, and on all architectures, <code>FP</code> (<code>RBP</code>) is kept at the top of the frame, just below return address/stack args, and used to access stack args; and <code>SP</code> (<code>RSP</code>) is kept at the bottom of the frame, as required (redzone notwithstanding). All stackslots and spillslots are accessed via offsets from <code>SP</code>. </p>\n<p>If part of the frame is variable, we'll need to either start accessing the fixed part via negative offsets from <code>FP</code>, or move <code>FP</code> below the fixed part and above the variable part, or keep another base register. The third is not great (extra register pressure). The first was how my original aarch64 ABI impl worked, but we switched from negative-from-FP to positive-from-SP since the encoding is more efficient. So we're left with the second, which is I think how other compilers also handle variable frame sizes on aarch64 (?). The issue with that is that we share the generic ABI code with x64, and on x64, we have to keep <code>RBP</code> at the top of the frame in the Windows Fastcall ABI (EDIT: and so we always do, for uniformity). Also relevant: there's support for omitting frame pointer setup when unneeded (in leaf functions at least); that interacts with this decision too.</p>\n<p>So we can definitely work this out, but we'll need to probably add \"modes\" to the ABI: where is FP, from which base register are (i) args, (ii) fixed slots, (iii) variable slots accessed, how unwind info is emitted correctly in all cases, etc. Lots of interacting moving parts.</p>\n<p>All of the above is needed for e.g. <code>alloca()</code> support as well, and is not unique to runtime-variable-sized types, but this may be the thing that forces the need first; so, thanks for pioneering the trail :-)</p>\n</blockquote>",
        "id": 265718751,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640111247
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-999006855\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Ah, another option I missed: variable part in the middle, fixed part at the bottom of the stack frame; then FP at the top and used to access args, as today, and SP at the bottom with fixed (independent of variable sizes) offsets for normal stackslots/spillslots. I think that satisfies all the constraints we have today (but not <code>alloca()</code>; the thing that makes VST-slots \"weaker\" than alloca in requirements is that we can know the size at prologue time rather than throughout the function body).</p>\n</blockquote>",
        "id": 265719927,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640111895
    },
    {
        "content": "<p>penzn <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-999034781\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>@penzn I thought it was still a possibility that the flexible spec would support setting the length at runtime?</p>\n</blockquote>\n<p>@sparker-arm, there is an idea to support setting 'current' length at runtime, RISC-V style, but the maximum available was always meant to be determined before, in the spirit of straight-forward compilation support.</p>\n<blockquote>\n<p>That would only work for jit compilation and not aot compilation. With aot compilation it may not be known what cpu it runs on.</p>\n</blockquote>\n<p>@bjorn3, valid point - how does AOT compilation currently handle target features?</p>\n</blockquote>",
        "id": 265724634,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640114636
    },
    {
        "content": "<p>penzn edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-999034781\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>@penzn I thought it was still a possibility that the flexible spec would support setting the length at runtime?</p>\n</blockquote>\n<p>@sparker-arm, there is an idea to support setting 'current' length at runtime, RISC-V style, but the maximum available was always meant to be determined before, in the spirit of straight-forward compilation support. Doing something like that isn't impossible, but would most likely require dynamic dispatch, and was considered out of scope.</p>\n<blockquote>\n<p>That would only work for jit compilation and not aot compilation. With aot compilation it may not be known what cpu it runs on.</p>\n</blockquote>\n<p>@bjorn3, valid point - how does AOT compilation currently handle target features?</p>\n</blockquote>",
        "id": 265724885,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640114769
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-999046584\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>There is a list of target features. When doing AOT compilation you can choose a list of allowed target features. The produced executable will then run on all cpus supporting all these target features. This list is generally chosen very conservatively to maximize the amount of cpus it works on. For example only sse and sse2 are enabled by default by rustc on x86_64. This allows at most 128 bit vectors despite the fact that modern cpus support 512 bit vectors through avx512. You can enable avx (for 256 bit vectors) or avx512 (for 512 bit vectors) but then it won't run on older cpus. Arm's SVE however allows you to compile once with the SVE target feature enabled and then it will use eg 512 bit vectors on cpus that support them while retaining compatibility with cpus that only support 128 bit vectors.</p>\n</blockquote>",
        "id": 265726483,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640115726
    },
    {
        "content": "<p>penzn <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-999360429\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>It sounds like the same would work here, when the user requests AVX instructions, they are going to get 256-bit vectors, SSE - 128-bit and so on.</p>\n</blockquote>",
        "id": 265775172,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640159696
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-999717889\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>variable part in the middle, fixed part at the bottom of the stack frame; then FP at the top and used to access args, as today, and SP at the bottom with fixed (independent of variable sizes) offsets for normal stackslots/spillslots.</p>\n</blockquote>\n<p>@cfallin  I think you're generally describing how AArch64 is currently handling this, with third register used in the presence of dynamic objects : <a href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp\">https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp</a></p>\n<p>@penzn Does the flexible spec state that the size of all the flexible types are the same? I had assumed not because of the various because of the various type.length operations, or are these available to just be more user friendly?</p>\n</blockquote>",
        "id": 265825517,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640191495
    },
    {
        "content": "<p>penzn <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1000060053\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>@penzn Does the flexible spec state that the size of all the flexible types are the same? I had assumed not because of the various because of the various type.length operations, or are these available to just be more user friendly?</p>\n</blockquote>\n<p>Yes, those are there to express things in number of elements instead of bytes, which would be more natural for loops and arrays (also cuts one instruction out, but that isn't a big win really). Spec does not say whether or not different types can have different byte length, but practically hardware length is the same for architectures that use same SIMD registers for different types. </p>\n</blockquote>",
        "id": 265885890,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640238511
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1000216132\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Thanks @penzn, though I feel having the size defined in the spec would be very useful in reducing the amount of ambiguity for any target independent parts of the compiler; the case of stack objects is a good example where, at the IR level, we can have homogeneously unsized slot type which can be (re)used by any flexible type. When it comes closer to codegen, it also makes the layout of the frame easier/smaller/efficient as, if they potentially had different sizes, we'd likely have to pad objects to a fixed alignment or have expensive ways of calculating the address of each object.</p>\n</blockquote>",
        "id": 265905608,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640257000
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1000345501\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>But now I remember that, for SVE, the sizeless registers aren't always equal - the predicate registers are x8 smaller than the data regs...</p>\n</blockquote>",
        "id": 265921842,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1640270140
    },
    {
        "content": "<p>sparker-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-999717889\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>variable part in the middle, fixed part at the bottom of the stack frame; then FP at the top and used to access args, as today, and SP at the bottom with fixed (independent of variable sizes) offsets for normal stackslots/spillslots.</p>\n</blockquote>\n<p>@cfallin  I think you're generally describing how AArch64 is currently handling this, with third register used in the presence of dynamic objects : <a href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp\">https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp</a></p>\n<p>@penzn Does the flexible spec state that the size of all the flexible types are the same? I had assumed not because of the various type.length operations, or are these available to just be more user friendly?</p>\n</blockquote>",
        "id": 266794543,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641294039
    },
    {
        "content": "<p>sparker-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1000345501\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>But now I remember that, for SVE, the sizeless registers aren't always equal - the predicate registers are x8 smaller than the data regs...</p>\n<p>EDIT: This actually shouldn't matter at the moment, while comparisons produce vector masks in the vector regs, but is something we should consider if predicates types are introduced.</p>\n</blockquote>",
        "id": 266916005,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641376571
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1006690055\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>@cfallin I've spent the last few days playing with the ABI layer, and I think I've stumbled upon (again) the limitation with the RegClass types, specifically while looking at callee saves... according to the AAPCS, in many cases SVE regs are treated the same as Neon but there are cases where the whole 'Z' register needs to be saved, and I'm not sure how to handle this while we just have shared V128 registers for Neon and SVE.</p>\n<p>So two questions really: can you think of a way around this, and/or do we need to follow the AAPCS? RegClass is used quite a bit in the ABI layer so I'm assuming there's going to be more problems like this.</p>\n</blockquote>",
        "id": 267074727,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641483669
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1006945500\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Hmm, interesting; can you say more about what factors influence prologue/epilogue register save details? Is it just \"if you clobber the upper bits, save them\" or something like that? I think it might be reasonable to, as we scan the function body building up the clobber set during ABI processing, look at some information provided by an instruction (\"requires special save/restore\") and use that info as well.</p>\n<p>The basic abstraction at the regalloc layer is that we have disjoint classes of units to allocate; overlapping classes are a major refactor that would require quite a significant investment of time (a month or so in regalloc code, with significant correctness risk); so I think that we likely need to find a way to make this work without two different register classes that mean \"Z/vec reg as traditional vec reg\" and \"Z/vec reg as Z reg\". But it's fundamentally a single register, so this doesn't seem wrong to me. In a sense, the way that we use it is type information layered on top of the allocation itself.</p>\n</blockquote>",
        "id": 267116791,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641504276
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1007243869\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>It is when the routine receives and/or returns Z or predicate registers that the callee needs to save the whole Z register (z8-z23). From what you said though, I guess we could just grab the type information from the instruction so that we don't have to rely on RegClass? I definitely have no interest in trying to bend/break regalloc to the will of SVE, but if we can pass the high-level type information down then I think this will be fine. I still haven't looked at spill/restores though :)</p>\n</blockquote>",
        "id": 267165420,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641546166
    },
    {
        "content": "<p>sparker-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1007243869\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>It is when the routine receives and/or returns Z or predicate registers that the callee needs to save the whole Z register (z8-z23). From what you said though, I guess we could just grab the type information from the instruction so that we don't have to rely on RegClass? I definitely have no interest in trying to bend/break regalloc to the will of SVE, but if we can pass the high-level type information down then I think this will be fine. I still haven't looked at spill/restores though :)</p>\n<p>edit: But now from quickly glancing, I see that type information is passed around in the spill/restore APIs so I'm hopeful.</p>\n</blockquote>",
        "id": 267166992,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641547341
    },
    {
        "content": "<p>sparker-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1007243869\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>It is when the routine receives and/or returns Z or predicate registers that the callee needs to save the whole Z register (z8-z23). From what you said though, I guess we could just grab the type information from the instruction so that we don't have to rely on RegClass? I definitely have no interest in trying to bend/break regalloc to the will of SVE, but if we can pass the high-level type information down then I think this will be fine. I still haven't looked at spill/restores though :)</p>\n<p>edit: But now from quickly glancing, I see that type information is passed around in the spill/restore APIs so I'm hopeful.</p>\n<p>edit: And the only place that I've found which doesn't provide a virtual reg for spill/reload is in regalloc's get_stackmap_artefacts_at function...</p>\n</blockquote>",
        "id": 267174027,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641551706
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1007562586\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>@cfallin Do you think adding something like 'add_sizeless_def' to RegUsageCollector would be a suitable way to communicate between regalloc and cranelfit? I _think_ this would allow us to convert 'clobbered_registers' to hold a RealReg and bool to represent whether it is sizeless.</p>\n</blockquote>",
        "id": 267212154,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641574208
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1007642972\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>edit: But now from quickly glancing, I see that type information is passed around in the spill/restore APIs so I'm hopeful.</p>\n</blockquote>\n<p>Not anymore actually; see the recent fuzzbug fix (and followup issue <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3645\">#3645</a>) where we determined that this type information can be inaccurate in the presence of moves and move elision.</p>\n<p>There's a bit of subtlety here: the register allocator <em>should not</em> know about IR types in a non-opaque way; that's an abstraction leak and a correctness risk (what if it tries to do something with that info?). The allocator is a thing that hands out registers; registers are just black boxes that hold bits; modern aarch64 machines have Z registers; Cranelift can decide to put a Z-register-sized value, or a v128-sized value, or an f64-sized value, or anything else into that register. That's a clear delineation of responsibilities and if we blur that line, I fear we could have bigger correctness problems later (similar to the one CVE and another almost-CVE this area has given us when we do blur the line).</p>\n<p>The suggested fix in the issue above involves having the regalloc record type info alongside registers, but only to verify that moves are valid; we don't want it to actually peek into that type info.</p>\n<p>But, the ABI code is free to reason about how the function body uses registers. So what I imagine could work is that when we generate prologue/epilogue code, we can scan over parameter/return types (\"do we take or return a Z reg\" condition above) and determine what we actually clobber and what we need to save. If something also depends on whether instructions actually e.g. touch high bits or whatnot, we can scan instructions for that too. But that all stays within Cranelift; it doesn't involve regalloc changes.</p>\n<p>It's possible I'm missing some requirement here though -- is there some reason that we can't determine the info we need from scanning the code on the Cranelift side?</p>\n</blockquote>",
        "id": 267225229,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641580651
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1008776983\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Yes, I think anything should be possible in cranelift and a scan sounds fine - as long as cranelift still has type info at that point, otherwise manually matching SVE opcodes sounds like a bug waiting to happen too. But maybe it's also fine, for now, to treat all V128 regs like Z-regs.</p>\n<p>I agree that the regalloc shouldn't need to know about IR types and my concerns stem from (my lack of knowledge) and regallocs interest in sizes, but I think your patch remedies that :) Without IR types, I was imagining spill slots being re-used for RegClass::V128 with potentially mismatching sizes.</p>\n<p>Having static sizes for stack objects should make the rest of codegen more simple, though I imagine we may have to be conservative in an AOT setting and only support the minimum width. And, of course, a larger Z-reg will have a greater negative effect on stack usage for scalar FP and Neon too.</p>\n</blockquote>",
        "id": 267425961,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641813591
    },
    {
        "content": "<p>sparker-arm edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1008776983\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Yes, I think anything should be possible in cranelift and a scan sounds fine - as long as cranelift still has type info at that point, otherwise manually matching SVE opcodes sounds like a bug waiting to happen too. But maybe it's also fine, for now, to treat all V128 regs like Z-regs.</p>\n<p>I agree that the regalloc shouldn't need to know about IR types and my concerns stem from (my lack of knowledge) and regallocs interest in sizes, but I think your patch remedies that :) Without IR types, I was imagining spill slots being re-used for RegClass::V128 with potentially mismatching sizes.</p>\n<p>Having static sizes for stack objects should make the rest of codegen more simple, though I imagine we may have to be conservative in an AOT setting and only support the minimum width. And, of course, a larger Z-reg will have a greater negative effect on stack usage for scalar FP and Neon too.</p>\n<p>edit: I've just realized that userspace applications don't have the necessary privileges to set the vector length, so I can't see static sizes actually working for spill slots - unless we default to the maximum size and that doesn't seem like a good idea!</p>\n</blockquote>",
        "id": 267449545,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1641826942
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1039255750\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Gentle ping on this... the latest change adds sizeless stack instructions and a new slot type to clif and the frame layout has been modified.</p>\n</blockquote>",
        "id": 271846642,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1644854334
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1039659802\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Addendum to above: after reviewing the thread discussion above again, I see that it can actually be <em>both</em>: runtime-determined size, or compile-time-bound size. Things are a little clearer to me now, but then we do need to fill in details how the runtime-determined part works: how do we tell the ABI code what the size actually is?</p>\n<p>Maybe a useful way to look at this is: what are the semantics of the CLIF, separate from any target architecture? (There must be some such semantics, or else we can't sensibly talk about target-independent codegen and optimizations, and, e.g., the CLIF interpreter.) Perhaps there is some special kind of global value (we could define a new one for symbolic <code>VL</code> on aarch64, or use a \"load from this part of vmctx\" op) that we can feed to a \"sizeless vector\" entity that actually gives it its size?</p>\n<p>So something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">size0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vl</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">dynslot0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dynamically_sized_slot</span><span class=\"w\"> </span><span class=\"n\">size0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">dynslot1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dynamically_sized_slot</span><span class=\"w\"> </span><span class=\"n\">size0</span><span class=\"w\"></span>\n\n<span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"n\">block0</span>:\n    <span class=\"nc\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dynamically_sized_vector_load</span><span class=\"w\"> </span><span class=\"n\">dynslot0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(with more concise keywords as desired)</p>\n<p>In that case, I'd prefer to call it a \"dynamically-sized\" vector, as sketched above, and I'd prefer for the compile-time binding to be thought of as a legalization pass (as you aluded to above) that's sort of like constant propagation: basically we replace all <code>dynamically_sized_slot</code> slots with normal slots with a given type.</p>\n<p>Does this seem reasonable?</p>\n</blockquote>",
        "id": 271902294,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1644879806
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1040167211\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>@cfallin Many thanks for taking another look!</p>\n<blockquote>\n<p>In other words, at what time do we know the actual size of the vectors, and are they all the same size, or a different size per vector?</p>\n</blockquote>\n<p>This needs to be defined by the flexible vector spec and it's my view that all the current flexible vector types should be specified to have the same size as each other. My current implementation reports a single size for all such vector types and they're all treated the same throughout compilation.</p>\n<blockquote>\n<p>seems unnecessary. In a sense, in this design the CLIF is just \"polymorphic on vector type\"; we can monomorphize for, say, 256 or 512 bits, and then the rest of the pipeline works as-is today, just with another register class.</p>\n</blockquote>\n<p>Yes, with the current proposal we are unable to provide proper dynamically sized/sizeless support, only partially, but we are still mapping to V128 registers as, without aliasing info, I cannot see how another using register class would be a feasible option for SVE (I don't know about AVX and friends).</p>\n<blockquote>\n<p>if we really do expect this to be a runtime-bound value (say, libc during startup detects CPU features and then the rest of our code uses N-bit vectors accordingly)</p>\n</blockquote>\n<p>To clarify, for proper SVE support, we wouldn't go for the route of querying the vector width and would instead produce a fully generic program. And I assume that passing feature flags to enable SVE, AVX, etc... would be a perfectly reasonable use case.</p>\n<blockquote>\n<p>Perhaps there is some special kind of global value (we could define a new one for symbolic VL on aarch64, or use a \"load from this part of vmctx\" op) that we can feed to a \"sizeless vector\" entity that actually gives it its size?</p>\n</blockquote>\n<p>I'm not sure if this would be necessary, it just seems like sugaring to me, as we could surely define the same semantics on the <code>explicit_sizeless_slot</code> entities and their accessing instruction counterparts. After all, the actual semantics, whether on a symbol or instruction, are defined by whatever machine, or interpreter, we're running on. Additionally, we (flexible vector spec) also have instructions to query for the vector length so I would be keen to avoid having a global value which may confuse things. I feel that we should define the semantics of sizeless/dynamic slots in terms of the <code>vec.*.length</code> operations. How does that sound to you?</p>\n<blockquote>\n<p>I'd prefer for the compile-time binding to be thought of as a legalization pass (as you aluded to above) that's sort of like constant propagation: basically we replace all dynamically_sized_slot slots with normal slots with a given type.</p>\n</blockquote>\n<p>For now, this seems more than reasonable enough to me! Once splillslots had a fixed size I figured this would make the most sense, but I still mainly wanted to see how the rest of the ABI would cope with the notion of sizeless type.</p>\n<p>I also perfectly happy with using the 'dynamic' nomenclature and sorry if I've missed any of your other points or questions.<br>\n</p>\n</blockquote>",
        "id": 271960810,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1644924810
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1042488438\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>@cfallin Many thanks for taking another look!</p>\n<blockquote>\n<p>In other words, at what time do we know the actual size of the vectors, and are they all the same size, or a different size per vector?</p>\n</blockquote>\n<p>This needs to be defined by the flexible vector spec and it's my view that all the current flexible vector types should be specified to have the same size as each other. My current implementation reports a single size for all such vector types and they're all treated the same throughout compilation.</p>\n</blockquote>\n<p>FWIW, I'd prefer that we define how our vector mechanism works within CLIF, independently of the \"upstream\" flexible vector spec; we can always update our semantics if needed, but we should err on the side of explicitness.</p>\n<p>I think that \"each dynamically-sized vector can have its own size\" may actually be more logically consistent (see more below) if things are implemented at the CLIF-primitive level in the way I'm imagining, but I could see either way working.</p>\n<blockquote>\n<blockquote>\n<p>Perhaps there is some special kind of global value (we could define a new one for symbolic VL on aarch64, or use a \"load from this part of vmctx\" op) that we can feed to a \"sizeless vector\" entity that actually gives it its size?</p>\n</blockquote>\n<p>I'm not sure if this would be necessary, it just seems like sugaring to me, as we could surely define the same semantics on the <code>explicit_sizeless_slot</code> entities and their accessing instruction counterparts. After all, the actual semantics, whether on a symbol or instruction, are defined by whatever machine, or interpreter, we're running on.</p>\n</blockquote>\n<p>This I actually disagree more with and I think it's important to spell out the principle at play: the whole point of a machine-independent IR is that the semantics do <em>not</em> depend on the machine or interpreter we're running on. If we have special vector instructions, or types, that behave differently according to the underlying platform, then:</p>\n<ul>\n<li>It's impossible to reason about how we can analyze or mutate such programs, unless we consider the set of all possible behaviors over all possible platforms (current and future);</li>\n<li>It's impossible to validate the behavior on one platform or execution strategy against that of another (e.g., differential fuzzing of machine code against CLIF interpreter);</li>\n<li>We get a constant stream of bugs where functionality that worked fine on one platform under development breaks on other platforms;</li>\n<li>Formal verification efforts fall over, because \"what does the IR mean\" is a complex question with no single answer.</li>\n</ul>\n<p>(There are a few places where this general principle isn't true and I want to fix them eventually; e.g. \"native endian\" loads/stores.)</p>\n<p>So I think a better starting point is to define an abstraction, whatever it may look like, that can (i) implement what we need (here, the Wasm flexible vector spec), and (ii) be mapped relatively straightforwardly to the machine architectures we know/care about.</p>\n<p>A suggestion below:</p>\n<blockquote>\n<p>Additionally, we (flexible vector spec) also have instructions to query for the vector length so I would be keen to avoid having a global value which may confuse things. I feel that we should define the semantics of sizeless/dynamic slots in terms of the <code>vec.*.length</code> operations. How does that sound to you?</p>\n</blockquote>\n<p>The reason that things like the stack check, or location of heaps, are defined via the \"global value\" abstraction (really a limited expression language that can express certain inputs like vmctx, constants, adds, and loads) is that we need to know some values before the body of the function starts executing. For example, the prologue code needs to know about stack limits before the first instruction.</p>\n<p>The general hierarchy of CLIF is that (i) we have global values, which define \"environment/context\"; (ii) we have entities, like heaps or slots, and some of these entities are parameterized on the global values; (iii) we have instructions, some of which use entities.</p>\n<p>Since a stack slot is an entity used by certain instructions, and since we need to know the size of stack slots to allocate the stack frame in the prologue, it makes more sense to me that we would have a kind of entity that is a dynamic slot, and that entity uses a global value to define its size in bytes. In contrast, trying to recover size of the slot from the instructions that use it doesn't solve the problem of knowing slot size at prologue time, and it feels more fragile in general.</p>\n<p>We could define new \"roots\" in the global-value expression language that refer to a machine register (<code>VL</code>?) or a platform-specific constant. Note that by having these machine-specific inputs reified as global values, we have a single place to encapsulate this nondeterminism/platform-specific behavior (basically an explicit input to the function), so we can reason about the rest of the CLIF semantics in a machine-independent way.</p>\n<p>I <em>think</em> this design fits all of the criteria:</p>\n<ul>\n<li>It allows for both runtime determination of vector size (via machine state or via some software-defined field in vmctx or whatnot) and compile-time fixing of vector size (turn the dynslot into a slot with a particular type);</li>\n<li>It allows the ABI code to know the size of all dynamically-sized slots at function entry;</li>\n<li>It fits within existing CLIF design;</li>\n<li>It maintains the property that CLIF is platform-independent.</li>\n<li>It can be edited by a pass that converts dynslots to slots.</li>\n</ul>\n<p>Does that make sense in general? I think we can tweak the design a bit if needed but now that I understand the general outline of what is needed, that seems (to me at least!) like the direction that would fit best with the rest of the compiler...</p>\n</blockquote>",
        "id": 272204808,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1645062747
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1042840144\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>Does that make sense in general?</p>\n</blockquote>\n<p>Thanks for the clear explanation of the CLIF hierachy, with that context I agree that a global VL sounds best.</p>\n<blockquote>\n<p>We could define new \"roots\" in the global-value expression language that refer to a machine register (VL?) or a platform-specific constant. Note that by having these machine-specific inputs reified as global values, we have a single place to encapsulate this nondeterminism/platform-specific behavior (basically an explicit input to the function)</p>\n</blockquote>\n<p>This is a particularly compelling argument, but I still don't think a global VL solves all our problems...</p>\n<blockquote>\n<p>I think that \"each dynamically-sized vector can have its own size\" may actually be more logically consistent (see more below) if things are implemented at the CLIF-primitive level in the way I'm imagining</p>\n</blockquote>\n<p>So, my reasoning for having a fixed width for all these vector types is for same the reasons you've raised about avoiding machine dependent semantics in the IR (a big yes to all those). Without one VL to rule them all, in becomes very difficult (impossible?) for us to reason about what is valid. But the root cause of the issue is really due the weak nature of the new types that I've proposed, which are no more than the flexible vector types.</p>\n<p>So, with a global value for VL (dyn_slot size in bytes) I'd also propose that all our dynamically sized vector types are specified with a shape, not just a type, so we have a new family of types with a dynamic factor such TypexLanesxDynFactor, i.e i32x4xN. Where N is another target-defined constant and 32x4xN &lt;= VL. I think this change would enable dynamic and fixed types to play nicely with each other and enable validation.</p>\n<p>What do you think?</p>\n</blockquote>",
        "id": 272244558,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1645096449
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1043791686\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Ah, that's interesting, I didn't realize before but agree now that the types need to somehow be linked to the dynamic factor as well!</p>\n<p>I find myself a little bit allergic to global state or special singletons, though, so I'm not completely sure I like a \"there is one global factor that alters the special xN types\"; but maybe there's something more general we can do. What if we have a first-class notion of \"dynamic type\" as a CLIF entity, and then feed this type both into the dynslot, and refer to it with an indexed <code>Type</code>?</p>\n<p>So something like:</p>\n<div class=\"codehilite\" data-code-language=\"plain\"><pre><span></span><code>function %f() {\n  gv0 = vector_length_reg  ; VL reg\n  dt0 = i32 * gv0          ; \"dynamic type 0\" -- defines shape/size of `dt0` below\n  dynslot0 = slot dyntype0\n\nblock0:\n  v0 = load.dt0 dynslot0\n  v1 = iadd.dt0 v0, v0\n  ; ...\n}\n</code></pre></div>\n<p>In other words, we have a set of types <code>dt0</code>..<code>dtN</code> (pre-define some range of our <code>Type</code> for this; 64 values maybe?). Then we can (i) define slots of this type, and (ii) load, store, do all the other things with this type, just like with values of any other type.</p>\n<p>This seems at least to me like an abstraction that can express whatever the higher-level \"flexible vector\" use-cases require, and we can map it to any hardware with a dynamic fallback and certain combinations (e.g. types known to use <code>vector_length_reg</code> on aarch64) to more efficient ISA extensions. It allows us to typecheck the IR like we do with other types currently, and it allows us to know the stack-frame size at function entry time. It's possible I've missed some requirements though -- thoughts/concerns?</p>\n</blockquote>",
        "id": 272354260,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1645153094
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1043791686\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Ah, that's interesting, I didn't realize before but agree now that the types need to somehow be linked to the dynamic factor as well!</p>\n<p>I find myself a little bit allergic to global state or special singletons, though, so I'm not completely sure I like a \"there is one global factor that alters the special xN types\"; but maybe there's something more general we can do. What if we have a first-class notion of \"dynamic type\" as a CLIF entity, and then feed this type both into the dynslot, and refer to it with an indexed <code>Type</code>?</p>\n<p>So something like:</p>\n<div class=\"codehilite\" data-code-language=\"plain\"><pre><span></span><code>function %f() {\n  gv0 = vector_length_reg  ; VL reg\n  dt0 = i32 * gv0          ; \"dynamic type 0\" -- defines shape/size of `dt0` below\n  dynslot0 = slot dt0\n\nblock0:\n  v0 = load.dt0 dynslot0\n  v1 = iadd.dt0 v0, v0\n  ; ...\n}\n</code></pre></div>\n<p>In other words, we have a set of types <code>dt0</code>..<code>dtN</code> (pre-define some range of our <code>Type</code> for this; 64 values maybe?). Then we can (i) define slots of this type, and (ii) load, store, do all the other things with this type, just like with values of any other type.</p>\n<p>This seems at least to me like an abstraction that can express whatever the higher-level \"flexible vector\" use-cases require, and we can map it to any hardware with a dynamic fallback and certain combinations (e.g. types known to use <code>vector_length_reg</code> on aarch64) to more efficient ISA extensions. It allows us to typecheck the IR like we do with other types currently, and it allows us to know the stack-frame size at function entry time. It's possible I've missed some requirements though -- thoughts/concerns?</p>\n</blockquote>",
        "id": 272354267,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1645153132
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1047608601\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Creating a type in IR sounds rather useful, I had no idea that it was possible! Could you point me at an example if we're already doing this for something else?</p>\n<p>So, at least for SVE, <code>vector_length_reg</code> will return the bit/byte width of either the Z-regs, or the predicates - both of which are scalable but are sized differently.  So, I think we need to parameterize our special operation with a vector type, and move away from the notion of a VL register:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">f</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">gv0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dyn_scale</span><span class=\"p\">.</span><span class=\"n\">i32x4</span><span class=\"w\">  </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">How</span><span class=\"w\"> </span><span class=\"n\">many</span><span class=\"w\"> </span><span class=\"n\">i32x4</span><span class=\"w\"> </span><span class=\"n\">vectors</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">fit</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">register</span><span class=\"o\">?</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">dt0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i32x4</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">gv0</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">dynslot0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slot</span><span class=\"w\"> </span><span class=\"n\">dt0</span><span class=\"w\"></span>\n\n<span class=\"n\">block0</span>:\n  <span class=\"nc\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"n\">dt0</span><span class=\"w\"> </span><span class=\"n\">dynslot0</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"p\">.</span><span class=\"n\">dt0</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I believe this still provides all the characteristics we're looking for, and should make lowering more efficient with better type info. Does that look okay?</p>\n<p>My one concern is passing a type, instead of a size, to the slot as this is very different to the current way of doing things, but I will trust that it's feasible.</p>\n</blockquote>",
        "id": 272780019,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1645523142
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1048035168\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>Creating a type in IR sounds rather useful, I had no idea that it was possible! Could you point me at an example if we're already doing this for something else?</p>\n</blockquote>\n<p>I don't think we do anything of the sort currently -- it's a new idea :-) But, yes, it certainly seems possible to me. This will change some of the internal signatures, e.g. <code>Type</code> no longer always knows its size -- it could return an <code>Option&lt;usize&gt;</code> from <code>bits()</code> or it could return a <code>TypeSize</code> with <code>Static(usize)</code> and <code>Dynamic(ir::Value)</code> arms, I suppose, and to get the latter it would need the <code>&amp;ir::Function</code> as an argument. But all of this seems reasonable to me at least.</p>\n<blockquote>\n<p>So, at least for SVE, <code>vector_length_reg</code> will return the bit/byte width of either the Z-regs, or the predicates - both of which are scalable but are sized differently. So, I think we need to parameterize our special operation with a vector type, and move away from the notion of a VL register:</p>\n<p>```<br>\nfunction %f() {<br>\n  gv0 = dyn_scale.i32x4  ; How many i32x4 vectors can fit in a register?<br>\n  dt0 = i32x4 * gv0<br>\n  dynslot0 = slot dt0</p>\n<p>block0:<br>\n  v0 = load.dt0 dynslot0<br>\n  v1 = iadd.dt0 v0, v0<br>\n  ; ...<br>\n}<br>\n```</p>\n<p>I believe this still provides all the characteristics we're looking for, and should make lowering more efficient with better type info. Does that look okay?</p>\n</blockquote>\n<p>I think so, yes. Just to make sure I understand, the <code>dyn_scale</code> global value will be determined based on a known target microarchitecture/ISA level? Or read/computed from special register(s) in the function prologue?</p>\n<blockquote>\n<p>My one concern is passing a type, instead of a size, to the slot as this is very different to the current way of doing things, but I will trust that it's feasible.</p>\n</blockquote>\n<p>Yes, I think this actually makes more sense overall: associating the slot with a type feels more appropriate than requiring the IR producer to match the size given to the slot entity with the known size of the loads and stores used to access it.</p>\n</blockquote>",
        "id": 272837331,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1645550754
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1048563919\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't think we do anything of the sort currently -- it's a new idea :-) But, yes, it certainly seems possible to me.</p>\n</blockquote>\n<p>Okay :) sounds like I'll be kept busy for a while hacking on the type system!</p>\n<blockquote>\n<p>Just to make sure I understand, the dyn_scale global value will be determined based on a known target microarchitecture/ISA level? Or read/computed from special register(s) in the function prologue?</p>\n</blockquote>\n<p>Yes, in most cases it will just be a constant set in the target backend. If/when we add fully dynamic support for SVE, it will be an instruction or two, in the prologue, that reads the runtime VL.</p>\n</blockquote>",
        "id": 272919685,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1645606553
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1055589568\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Hi @cfallin, now that I've had some time to revisit the meta level of cranelift, I'm still struggling to see how these dynamically created types would work. It just seems to be too against how types and instructions are currently implemented.</p>\n<p>During the parsing we can check that dyn_scale and our dynamic type have been declared with the same base vector type, that's okay...At the IR level, the mechanical bits seem fine too: Types are just u8 values, we reserve some of those for dynamic types, as I have done for the original sizeless types, and these should be named such as I8X16XN. Implementing methods to handle the dynamic addition is not an issue. But this doesn't seem to tie dyn_scale value to the type in the way you would like, these are concrete types and not connected to a global value.</p>\n<p>I actually got so lost in the meta layers that I actually can't remember which part made my mind finally fall over :) I think my problem comes when implementing the polymorphic instruction generation, when we want to iterate through concrete types. From the description above, they seem like concrete types (just a u8 with a bit for dynamic) but from the user perspective they are not. In the meta level, I've tried to generate a set of types that have a reference to an IR entitty, which then seems superficial since that entity isn't actually part of the type. Does any of this successfully convey my pain?</p>\n</blockquote>",
        "id": 273662058,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1646150102
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1055735821\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>@sparker-arm , I'm happy to help work out implementation/prototype details -- do you have a WIP branch you can point me to that demonstrates what you're thinking / what issues you're running into?</p>\n<blockquote>\n<p>Hi @cfallin, now that I've had some time to revisit the meta level of cranelift, I'm still struggling to see how these dynamically created types would work. It just seems to be too against how types and instructions are currently implemented.</p>\n<p>During the parsing we can check that dyn_scale and our dynamic type have been declared with the same base vector type, that's okay...At the IR level, the mechanical bits seem fine too: Types are just u8 values, we reserve some of those for dynamic types, as I have done for the original sizeless types, and these should be named such as I8X16XN. Implementing methods to handle the dynamic addition is not an issue. But this doesn't seem to tie dyn_scale value to the type in the way you would like, these are concrete types and not connected to a global value.</p>\n</blockquote>\n<p>I don't think that the IR literally needs to have a <code>Type</code> that refers to/holds an IR entity, or somesuch; I'm imagining something like:</p>\n<ul>\n<li><code>Type</code> has a new \"dynamically-sized type\" mode, which reserves some of the index space for <code>dt0</code>..<code>dtN</code></li>\n<li>In <code>ir::Function</code>, we have a new <code>dyn_types</code> vector that contains structs that define each dynamic type, something like:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Function</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"w\">    </span><span class=\"n\">dyn_types</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">DynType</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// A dynamically-sized type. Type `dtN` refers to the definition in `dyn_types[N]`.</span>\n<span class=\"k\">struct</span> <span class=\"nc\">DynType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// The dynamically-sized type is defined in terms of a base type and a global value that indicates</span>\n<span class=\"w\">    </span><span class=\"sd\">/// how many of those base-type elements this type contains.</span>\n<span class=\"w\">    </span><span class=\"n\">base_type</span>: <span class=\"nc\">Type</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">length</span>: <span class=\"nc\">GlobalValue</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It isn't really an issue that the <code>DynType</code> isn't literally part of the <code>Type</code>; the <code>Type</code> contains an index, and we can look up the <code>DynType</code> given the <code>Function</code> context.</p>\n<p>Possibly I'm missing some other difficulty here though? Are there places where it would be awkward to look up the <code>DynType</code> (I guess we need to think about what additional plumbing this requires)?</p>\n<blockquote>\n<p>I actually got so lost in the meta layers that I actually can't remember which part made my mind finally fall over :) I think my problem comes when implementing the polymorphic instruction generation, when we want to iterate through concrete types. From the description above, they seem like concrete types (just a u8 with a bit for dynamic) but from the user perspective they are not. In the meta level, I've tried to generate a set of types that have a reference to an IR entitty, which then seems superficial since that entity isn't actually part of the type. Does any of this successfully convey my pain?</p>\n</blockquote>\n<p>When generating code, I imagine there would be a case that matches on dynamic types, and then switches on the base type; so just as we today have cases for <code>i32x4</code> and <code>i64x2</code>, we would have cases for <code>i32xN</code> and <code>i64xN</code>. There's just one indirection to go look up the base type. Does that make sense?<br>\n</p>\n</blockquote>",
        "id": 273688511,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1646159492
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1056685367\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>It isn't really an issue that the DynType isn't literally part of the Type; the Type contains an index, and we can look up the DynType given the Function context.</p>\n</blockquote>\n<p>Okay, thanks, this sounds much more feasible and sorry I kinda missed this suggestion in your previous comment.</p>\n<p>One thing regarding the global value names, is it a fundamental property of clif that we need a prefix followed by a number? I was wondering whether we could have <code>Nxi32x4 = i32x4 * gv0</code> instead, which could make the IR more readable.</p>\n<blockquote>\n<p>I'm happy to help work out implementation/prototype details -- do you have a WIP branch you can point me to that demonstrates what you're thinking / what issues you're running into?</p>\n</blockquote>\n<p>I greatly appreciate the offer, but I think your above suggestion is enough to get me moving forward again. I will be on holiday for a couple weeks though, starting Friday, so please don't interpret my silence as being stuck again.</p>\n</blockquote>",
        "id": 273778921,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1646213790
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1057465698\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>It isn't really an issue that the DynType isn't literally part of the Type; the Type contains an index, and we can look up the DynType given the Function context.</p>\n</blockquote>\n<p>Okay, thanks, this sounds much more feasible and sorry I kinda missed this suggestion in your previous comment.</p>\n<p>One thing regarding the global value names, is it a fundamental property of clif that we need a prefix followed by a number? I was wondering whether we could have <code>Nxi32x4 = i32x4 * gv0</code> instead, which could make the IR more readable.</p>\n</blockquote>\n<p>The CLIF parser seems to be <a href=\"https://github.com/bytecodealliance/wasmtime/blob/7d1bc7d808dd197c410689bb3302310c68798609/cranelift/reader/src/lexer.rs#L322-L326\">built assuming the <code>entityN</code> syntax</a> and it does have a nice logical consistency to it, though I see the appeal of arbitrary type names as well... for now I think it's probably simplest to keep the same scheme for this new type of entity, but we can definitely discuss/refine syntax more when there's a prototype to play with, I think.</p>\n</blockquote>",
        "id": 273888844,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1646260800
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1103621661\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>@cfallin @abrown Would you be able to take a look at this again, please? I'm happy that everything ended up working as we discussed, and I'm kinda keen to move into a code RFC to better illustrate all the moving pieces.</p>\n</blockquote>",
        "id": 279513484,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1650443766
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1104896199\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Thanks @cfallin !</p>\n<blockquote>\n<p>The biggest question to me is how the pipeline lowers this to the existing stackslot abstractions; as we discussed earlier if all the sizes are initially compile-time constants then in theory the ABI implementation could remain unchanged, if we legalize beforehand. But for full generality maybe the ABI needs to be aware of the separate category of slots.</p>\n</blockquote>\n<p>Indeed, the current ABI changes that I've made aren't really needed for this initial fixed size implementation, but I've tried to implement it with true dynamic sizes, and general SVE, in mind.</p>\n<p>Speaking of which, my current plan for the code RFC is to avoid including any SVE codegen, except some changes to the ABI API, purely to avoid distractions from the IR and ABI changes (it already feels big enough to me). Do you think this is wise, or would you also prefer to see some SVE codegen too?</p>\n</blockquote>",
        "id": 279652242,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1650531027
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1105436382\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<blockquote>\n<p>Speaking of which, my current plan for the code RFC is to avoid including any SVE codegen, except some changes to the ABI API, purely to avoid distractions from the IR and ABI changes (it already feels big enough to me). Do you think this is wise, or would you also prefer to see some SVE codegen too?</p>\n</blockquote>\n<p>I think your incremental approach sounds good: best to get support for the dynamically-sized types in, handling/storing/spilling them, then we can add ISA support as a followup. Actually maybe there are (at least) three pieces: the dynamically-sized types and ABI support; then a \"polyfill\" without SVE, just NEON (and others could build the same with Intel SIMD if interested); then actually using the new hardware instructions. But, we don't need to fix the details here, they can change as needed I think.</p>\n</blockquote>",
        "id": 279703529,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1650558048
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1110618797\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Hi, it's been a week since I updated this so I'd now like to move this RFC into the final comment period. Thanks!</p>\n</blockquote>",
        "id": 280310840,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1651042845
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1111441855\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>@sparker-arm could you post a final-comment-period approval checklist? Then we can start to collect approvals and hopefully get this in soon!</p>\n<p>(+1 from me as well, i.e. feel free to mark me as checked already)</p>\n</blockquote>",
        "id": 280405488,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1651090726
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1111865380\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<h3>Stakeholders sign-off</h3>\n<p><strong>Arm</strong></p>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[x] @sparker-arm </li>\n</ul>\n<p><strong>Fastly</strong></p>\n<ul>\n<li>[x] @cfallin </li>\n<li>[ ] @fitzgen</li>\n<li>[ ] @alexcrichton </li>\n</ul>\n<p><strong>Intel</strong></p>\n<ul>\n<li>[x] @abrown </li>\n<li>[ ] @jb6740</li>\n</ul>\n<p><strong>Unaffliated</strong></p>\n<ul>\n<li>[ ] @bjorn3 </li>\n</ul>\n<p><strong>IBM</strong></p>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n</blockquote>",
        "id": 280457199,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1651132430
    },
    {
        "content": "<p>alexcrichton edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1111865380\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<h3>Stakeholders sign-off</h3>\n<p><strong>Arm</strong></p>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[x] @sparker-arm </li>\n</ul>\n<p><strong>Fastly</strong></p>\n<ul>\n<li>[x] @cfallin </li>\n<li>[ ] @fitzgen</li>\n<li>[x] @alexcrichton </li>\n</ul>\n<p><strong>Intel</strong></p>\n<ul>\n<li>[x] @abrown </li>\n<li>[ ] @jb6740</li>\n</ul>\n<p><strong>Unaffliated</strong></p>\n<ul>\n<li>[ ] @bjorn3 </li>\n</ul>\n<p><strong>IBM</strong></p>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n</blockquote>",
        "id": 280503452,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1651156726
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1111865380\">comment</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<h3>Stakeholders sign-off</h3>\n<p><strong>Arm</strong></p>\n<ul>\n<li>[ ] @akirilov-arm</li>\n<li>[x] @sparker-arm </li>\n</ul>\n<p><strong>Fastly</strong></p>\n<ul>\n<li>[x] @cfallin </li>\n<li>[x] @fitzgen</li>\n<li>[x] @alexcrichton </li>\n</ul>\n<p><strong>Intel</strong></p>\n<ul>\n<li>[x] @abrown </li>\n<li>[ ] @jb6740</li>\n</ul>\n<p><strong>Unaffliated</strong></p>\n<ul>\n<li>[ ] @bjorn3 </li>\n</ul>\n<p><strong>IBM</strong></p>\n<ul>\n<li>[ ] @uweigand</li>\n</ul>\n</blockquote>",
        "id": 280524125,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1651165009
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1122271301\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>I believe enough time has now passed? Can this now be merged?</p>\n</blockquote>",
        "id": 281810254,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1652182425
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1122532630\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Indeed, the FCP has now elapsed with no objections, so this RFC should now be merged! (I'm happy to click the button if you don't have permissions to do so, but we should also fix that if so)</p>\n</blockquote>",
        "id": 281839084,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1652195843
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1122697707\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>Great, I didn't think I had permissions! Thanks for all the help with this @cfallin </p>\n</blockquote>",
        "id": 281861737,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1652205180
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/19#issuecomment-1122703118\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/19\">issue #19</a>:</p>\n<blockquote>\n<p>It was just added apparently (thanks to Till); you're part of the Cranelift core org group now so it shouldn't be an issue in the future :-)</p>\n</blockquote>",
        "id": 281862624,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1652205557
    }
]